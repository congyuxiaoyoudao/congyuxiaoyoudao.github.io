<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Assignment 7. GAMES202 Homework 4 | The Only Problem's Blog</title><meta name=keywords content="GAMES202,BRDF"><meta name=description content="
好久不见！最近在忙别的工作，这几天难得有时间，赶紧把 202 系列作业做个收尾ε٩(๑> ₃ <)۶з！

0x00 To begin with
这篇文章将会包含以下内容：

 部分课程内容回顾
 GAMES202 作业 4

For reference👇：

📺B 站视频：







  
  GAMES202-高质量实时渲染


📦代码仓库：







  
  congyuxiaoyoudao/GAMES202_Homework at working


📃 







  
  Revisiting Physically Based Shading at Imageworks




master 分支上是 202 全部作业汇总，working 分支用于提交代码。需要原始作业可下载 master 分支的包

0x01 课程回顾 Recap
能量守恒的 BSDF Energy-Preserving BSDFs
Cook-Torrance 提出的微表面 BRDF 只考虑光线在表面经过一次弹射后出射到观察方向的能量，然而忽略了多次弹射最终出射到观察方向的能量，这就造成了能量损失。尤其是当材质的 roughness 较高时，G 项减小，多次弹射的比例增加，能量损失越严重。

2017 年 Kulla 和 Conty 受到 Disney Principle BRDF 的启发，提出了一种改进的方法，即通过引入一个能量补偿项，将多次弹射出射到观察方向的能量补充回来，就能近似地保持能量守恒。"><meta name=author content="The Only Problem"><link rel=canonical href=https://congyuxiaoyoudao.github.io/posts/assignments/games202-homework-4/><link crossorigin=anonymous href=/assets/css/stylesheet.452758010f0b7fc9ad7fa528ffdfdd8eb9e830816fb8c8119f16f39583297db8.css integrity="sha256-RSdYAQ8Lf8mtf6Uo/9/djrnoMIFvuMgRnxbzlYMpfbg=" rel="preload stylesheet" as=style><link rel=icon href=https://congyuxiaoyoudao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://congyuxiaoyoudao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://congyuxiaoyoudao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://congyuxiaoyoudao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://congyuxiaoyoudao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://congyuxiaoyoudao.github.io/posts/assignments/games202-homework-4/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css integrity=sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js integrity=sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js integrity=sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk crossorigin=anonymous onload='window.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\$$",right:"\\\\$$",display:!1},{left:"\\$$",right:"\\\\$$",display:!0}]})})'></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdn.bootcdn.net/ajax/libs/lxgw-wenkai-screen-webfont/1.7.0/style.min.css><meta property="og:url" content="https://congyuxiaoyoudao.github.io/posts/assignments/games202-homework-4/"><meta property="og:site_name" content="The Only Problem's Blog"><meta property="og:title" content="Assignment 7. GAMES202 Homework 4"><meta property="og:description" content=" 好久不见！最近在忙别的工作，这几天难得有时间，赶紧把 202 系列作业做个收尾ε٩(๑> ₃ <)۶з！
0x00 To begin with 这篇文章将会包含以下内容：
部分课程内容回顾 GAMES202 作业 4 For reference👇：
📺B 站视频： GAMES202-高质量实时渲染 📦代码仓库： congyuxiaoyoudao/GAMES202_Homework at working 📃 Revisiting Physically Based Shading at Imageworks master 分支上是 202 全部作业汇总，working 分支用于提交代码。需要原始作业可下载 master 分支的包
0x01 课程回顾 Recap 能量守恒的 BSDF Energy-Preserving BSDFs Cook-Torrance 提出的微表面 BRDF 只考虑光线在表面经过一次弹射后出射到观察方向的能量，然而忽略了多次弹射最终出射到观察方向的能量，这就造成了能量损失。尤其是当材质的 roughness 较高时，G 项减小，多次弹射的比例增加，能量损失越严重。
2017 年 Kulla 和 Conty 受到 Disney Principle BRDF 的启发，提出了一种改进的方法，即通过引入一个能量补偿项，将多次弹射出射到观察方向的能量补充回来，就能近似地保持能量守恒。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-14T00:00:00+00:00"><meta property="article:modified_time" content="2025-06-14T00:00:00+00:00"><meta property="article:tag" content="GAMES202"><meta property="article:tag" content="BRDF"><meta name=twitter:card content="summary"><meta name=twitter:title content="Assignment 7. GAMES202 Homework 4"><meta name=twitter:description content="
好久不见！最近在忙别的工作，这几天难得有时间，赶紧把 202 系列作业做个收尾ε٩(๑> ₃ <)۶з！

0x00 To begin with
这篇文章将会包含以下内容：

 部分课程内容回顾
 GAMES202 作业 4

For reference👇：

📺B 站视频：







  
  GAMES202-高质量实时渲染


📦代码仓库：







  
  congyuxiaoyoudao/GAMES202_Homework at working


📃 







  
  Revisiting Physically Based Shading at Imageworks




master 分支上是 202 全部作业汇总，working 分支用于提交代码。需要原始作业可下载 master 分支的包

0x01 课程回顾 Recap
能量守恒的 BSDF Energy-Preserving BSDFs
Cook-Torrance 提出的微表面 BRDF 只考虑光线在表面经过一次弹射后出射到观察方向的能量，然而忽略了多次弹射最终出射到观察方向的能量，这就造成了能量损失。尤其是当材质的 roughness 较高时，G 项减小，多次弹射的比例增加，能量损失越严重。

2017 年 Kulla 和 Conty 受到 Disney Principle BRDF 的启发，提出了一种改进的方法，即通过引入一个能量补偿项，将多次弹射出射到观察方向的能量补充回来，就能近似地保持能量守恒。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://congyuxiaoyoudao.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Assignments","item":"https://congyuxiaoyoudao.github.io/posts/assignments/"},{"@type":"ListItem","position":3,"name":"Assignment 7. GAMES202 Homework 4","item":"https://congyuxiaoyoudao.github.io/posts/assignments/games202-homework-4/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Assignment 7. GAMES202 Homework 4","name":"Assignment 7. GAMES202 Homework 4","description":" 好久不见！最近在忙别的工作，这几天难得有时间，赶紧把 202 系列作业做个收尾ε٩(๑\u0026gt; ₃ \u0026lt;)۶з！\n0x00 To begin with 这篇文章将会包含以下内容：\n部分课程内容回顾 GAMES202 作业 4 For reference👇：\n📺B 站视频： GAMES202-高质量实时渲染 📦代码仓库： congyuxiaoyoudao/GAMES202_Homework at working 📃 Revisiting Physically Based Shading at Imageworks master 分支上是 202 全部作业汇总，working 分支用于提交代码。需要原始作业可下载 master 分支的包\n0x01 课程回顾 Recap 能量守恒的 BSDF Energy-Preserving BSDFs Cook-Torrance 提出的微表面 BRDF 只考虑光线在表面经过一次弹射后出射到观察方向的能量，然而忽略了多次弹射最终出射到观察方向的能量，这就造成了能量损失。尤其是当材质的 roughness 较高时，G 项减小，多次弹射的比例增加，能量损失越严重。\n2017 年 Kulla 和 Conty 受到 Disney Principle BRDF 的启发，提出了一种改进的方法，即通过引入一个能量补偿项，将多次弹射出射到观察方向的能量补充回来，就能近似地保持能量守恒。\n","keywords":["GAMES202","BRDF"],"articleBody":" 好久不见！最近在忙别的工作，这几天难得有时间，赶紧把 202 系列作业做个收尾ε٩(๑\u003e ₃ \u003c)۶з！\n0x00 To begin with 这篇文章将会包含以下内容：\n部分课程内容回顾 GAMES202 作业 4 For reference👇：\n📺B 站视频： GAMES202-高质量实时渲染 📦代码仓库： congyuxiaoyoudao/GAMES202_Homework at working 📃 Revisiting Physically Based Shading at Imageworks master 分支上是 202 全部作业汇总，working 分支用于提交代码。需要原始作业可下载 master 分支的包\n0x01 课程回顾 Recap 能量守恒的 BSDF Energy-Preserving BSDFs Cook-Torrance 提出的微表面 BRDF 只考虑光线在表面经过一次弹射后出射到观察方向的能量，然而忽略了多次弹射最终出射到观察方向的能量，这就造成了能量损失。尤其是当材质的 roughness 较高时，G 项减小，多次弹射的比例增加，能量损失越严重。\n2017 年 Kulla 和 Conty 受到 Disney Principle BRDF 的启发，提出了一种改进的方法，即通过引入一个能量补偿项，将多次弹射出射到观察方向的能量补充回来，就能近似地保持能量守恒。\n有了渲染方程，我们可以很容易地求得微表面 BRDF 在观察方向 $\\mu_{o}$ 上出射的总能量：\n$$ E(\\mu_{o})=\\int_{0}^{2\\pi}\\int_{0}^{1}f(\\mu_{o},\\mu_{i},\\phi)\\mu_{i}d\\mu_{i}d\\phi $$ 这里记 $\\mu_{i}=\\sin \\theta,\\theta=n\\cdot \\mu_{i}$，之后就可以将 $f_{r}\\cos \\theta \\sin \\theta d\\theta d\\phi$ 写为 $f_{r}\\mu_{i} d\\mu_{i}d\\phi$。然而原 PPT 里提到的是记为 $\\cos \\theta$，不过就积分结果来说都一样\n$E(\\mu_{o})$ 的范围为 0-1，对于不同的 $\\mu_{o}$，$E(\\mu_{o})$ 的值也会发生变化。微表面 BRDF 的 $E(\\mu_{o})$ 会随着 roughness 的增加而衰减。为了弥补这部分能量，Kulla 和 Conty 设计了一个新的 BRDF lobe：\n$$ f_{ms}=\\frac{(1-E(\\mu_{o}))(1-E(\\mu_{i}))}{\\pi(1-E_{avg})},E_{avg}=2\\int_{0}^1E(\\mu)\\mu d\\mu $$ 其中 $f_{ms}$ 为弥补损失的 BRDF，$E_{avg}$ 为在所有观察方向下出射能量的平均值。同样计算这个 BRDF 在观察方向 $\\mu_{o}$ 上的积分：\n$$ \\begin{aligned} E_{ms}(\\mu_{o})\u0026=\\int_{0}^{2\\pi}\\int_{0}^{1}f_{ms}(\\mu_{o},\\mu_{i},\\phi)\\mu_{i}d\\mu_{i}d\\phi \\\\ \u0026=2 \\int_{0}^1 \\frac{(1-E(\\mu_{o}))(1-E(\\mu_{i}))}{\\pi(1-E_{avg})}\\mu_{i}d\\mu_{i}\\\\ \u0026=2 \\frac{1-E(\\mu_{o})}{1-E_{avg}}\\int_{0}^1(1-E(\\mu_{i}))\\mu_{i}d\\mu_{i}\\\\ \u0026= \\frac{1-E(\\mu_{o})}{1-E_{avg}}(1-E_{avg})\\\\ \u0026= 1-E(\\mu_{o}) \\end{aligned} $$ 将其加到原来的微表面 BRDF 上即可弥补损失：\n$$ E(\\mu_{o})+E_{ms}(\\mu_{o})\\equiv 1 $$ 计算 $E(\\mu)$ 和 $E_{avg}$ 都需要积分，我们可以在离线端预先计算好这两项，将其按需要的变量打表，存储在纹理上，然后渲染时对应查询即可。PPT 中指出 32×32 的大小的纹理就足够了，作业中则使用了更大的 128×128。\n颜色表面 Colored Surfaces 在上一节中，表面将所有入射的光全部反射，即光线不存在被吸收或者透射的情况。然而，绝大多数表面是带有颜色的，即其会吸收某种成分的光，这种情况下的能量损失是符合物理的，即 $E(\\mu)\u003c1$。\nKulla 和 Conty 受到 Jakob 等人的启发，多次弹射下能量是 diffuse 的，所以可以使用余弦加权的 Fresnel 项代表平均被反射的能量：\n$$ F_{avg}=2\\int_{0}^1F(\\mu)\\mu d\\mu $$ 我们已经知道所有反射出射的能量比例为 $E_{avg}$，那么因为微表面的遮挡而没有出射的能量比例则为 $1-E_{avg}$，这部分能量（即发生了二次 bounce）中又有 $F_{avg}$ 的比例能够被反射，所以经过 $n$ 次反射出射到观察方向的能量可以归纳为：\n$$ \\begin{aligned} E_{0}\u0026=F_{avg}E_{avg}\\\\ E_{1}\u0026=F_{avg}(1-E_{avg})F_{avg}E_{avg}\\\\ \\dots\\\\ E_{n}\u0026=F_{avg}^n (1-E_{avg})^n F_{avg}E_{avg} \\end{aligned} $$ 很显然这是一个等比数列，将其求和后即可得到所有经过多次弹射最终出射到观察方向的总能量：\n$$ E=F_{avg}E_{avg}\\sum_{k=0}^{\\infty}F_{avg}^k(1-E_{avg})^k=\\frac{F_{avg}E_{avg}}{1-F_{avg}(1-E_{avg})} $$ $E_{avg}$ 可以通过预计算得到，但是 $F_{avg}$ 无法这么做。所以 Kulla 和 Conty 分别对介电质和导体列出了两种前人用到的数值近似方法：\n如此，在渲染时即可采样 $E_{avg}$ 和根据表面性质近似 $F_{avg}$ 计算出颜色表面的出射能量比例，然后再将其与上节中没有能量吸收的 $f_{ms}$ 相乘即可。\n0x02 问题修复 TroubleShooting 做作业时遇到一些出现问题的地方，这里一并提一下：\n找不到 vec.h 未定义标识符“M_PI” uniform 变量 uEavgFLut 命名错误 第一个问题是配置问题，用 vscode 在 task.json 的 args 字段加上：\n1 \"-I\", 2\"${workspaceFolder}/assignment4/lut-gen/ext\", 第二个问题把所有 M_PI 改成 PI。\n第三个问题在 KullaContyMaterial.js 中，调用父类构造函数时传入了命名和 Shader 中不对应的 uniform 变量，把 uEavgFLut 改成 uEavgLut 即可。\n0x03 预积分 $E(\\mu)$ 蒙特卡洛求解 Monte Carlo 在 Emu_MC.cpp 的 IntegrateBRDF 中完成对 $E(\\mu)$ 的积分，使用蒙特卡洛方法在半球上均匀采样入射光方向，求解这个积分。积分内部为 BRDF 以及 cos 项：\n$$ f_{r}(i,o)=\\frac{F(i,h)G(i,o,h)D(h)}{4(n\\cdot i)(n\\cdot o)},\\cos \\theta=n\\cdot i $$ F，G，D 的实现框架中均已给出，按需调用即可。\n1Vec3f IntegrateBRDF(Vec3f V, float roughness, float NdotV) { 2 float A = 0.0; 3 float B = 0.0; 4 float C = 0.0; 5 const int sample_count = 1024; 6 Vec3f N = Vec3f(0.0, 0.0, 1.0); 7 8 samplePoints sampleList = squareToCosineHemisphere(sample_count); 9 for (int i = 0; i \u003c sample_count; i++) { 10 // calculate (fr * ni) / p_o here 11 Vec3f L = sampleList.directions[i]; 12 float pdf = sampleList.PDFs[i]; 13 14 float NdotL = dot(N,L); 15 Vec3f H = normalize(V+L); 16 17 // here we assume all lights are reflected, no absorption! 18 // deal with color later 19 float F = 1.0; 20 float NDF = DistributionGGX(N, H, roughness); 21 float G = GeometrySmith(roughness, NdotV, NdotL); 22 23 float nom = F * NDF * G; 24 float denom = std::max(4.0 * NdotL * NdotV,0.001); 25 float fr = nom / denom; 26 27 // accumulate each component 28 A = B = C +=fr*NdotL/pdf; 29 30 } 31 32 return {A / sample_count, B / sample_count, C / sample_count}; 33} 运行程序即可得到这样一张 LUT：\n可以看到随着粗糙度降低（自上而下），噪声越来越明显。这是因为低粗糙度的微表面法线 $m$ 集中在宏观法线 $n$ 附近，但通过随机采样入射光方向 $i$ 计算得到的半程向量 $h$ 则不然，因此导致低粗糙度下积分值的方差显著增加。但我们可以通过对微表面法线 $m$ 进行重要性采样来改善这个问题，即使得采样的 $m$ 更多地位于 $n$ 附近。\n重要性采样求解 Importance Sampling 最终的任务仍然是采样 $i$ 和计算 $\\frac{f_{r}(i,o,h)(i,n)}{pdf_{i}(i)}$，但现在 $i$ 并不由直接采样得到，而是根据某个微表面法线分布模型重要性采样得到的微表面法向 $m$ 间接求解。\n框架中使用的 NDF 为 GGX 分布，我们需要根据该分布生成采样的微表面法向 $m$，再由 $m$ 和 $o$ 反求入射方向 $i$。\n由微表面法线分布模型的性质，可以计算出采样 $m$ 的概率密度：\n$$ pdf_{m}(m)=D(m)(m\\cdot n) $$ 通过该概率密度，可以计算出该分布下对应的采样点：\n$$ \\begin{aligned} \\theta_{m}\u0026=\\arctan\\left( \\frac{\\alpha \\sqrt{ \\xi_{1} }}{\\sqrt{ 1-\\xi_{1} }} \\right)\\\\ \\phi_{h}\u0026=2\\pi \\xi_{2} \\end{aligned} $$ 其中，$\\alpha=roughness^{2},\\xi_{1},\\xi_{2}\\in[0,1)$。\n在 Emu_IS.cpp 的 ImportanceSampleGGX 函数中，完成重要性采样的逻辑，并返回切线空间的微表面法线 $h$。\n1Vec3f ImportanceSampleGGX(Vec2f Xi, Vec3f N, float roughness) { 2 float a = roughness * roughness; 3 4 // in spherical space - Bonus 1 5 float Xi1 = Xi.x; 6 float Xi2 = Xi.y; 7 float theta = atan(a*sqrt(Xi1)/sqrt(1-Xi1)); 8 float phi = 2.0 * PI * Xi2; 9 10 // from spherical space to cartesian space - Bonus 1 11 float x = cos(phi)*sin(theta); 12 float y = sin(phi)*sin(theta); 13 float z = cos(theta); 14 15 // tangent coordinates - Bonus 1 16 Vec3f up = abs(N.z) \u003c 0.999 ? Vec3f(0.0, 0.0, 1.0) : Vec3f(1.0, 0.0, 0.0); // N is fixed 001 so not select 001 17 Vec3f tangent = normalize(cross(up,N)); 18 Vec3f bitangent = cross(N,tangent); 19 20 // transform H to tangent space - Bonus 1 21 Vec3f H = normalize(tangent*x + bitangent*y + N*z); 22 return H; 23} 接下来计算 $\\frac{f_{r}(i,o,h)(i,n)}{pdf_{i}(i)}$ 的值，需要先将采样 $m$ 的概率密度转化为采样 $i$ 的概率密度：\n$$ pdf_{i}(i)=pdf_{m}(m)\\left\\lvert \\left\\lvert \\frac{\\partial\\omega_{m}}{\\partial \\omega_{i}} \\right\\rvert \\right\\rvert =\\frac{D(m)(m\\cdot n)}{4(i\\cdot m)} $$ 所以最终需要累加的权重为：\n$$ \\begin{aligned} weight(i)\u0026=\\frac{f_{r}(i,o,h)(i,n)}{pdf_{i}(i)} \\\\ \u0026=\\frac{F(i,m)G(i,o,m)D(m)}{4(n\\cdot i)(n\\cdot o)}\\cdot(n\\cdot i)\\cdot \\frac{4(i\\cdot m)}{D(m)(n\\cdot m)} \\\\ \u0026=\\frac{(o\\cdot m)G(i,o,h)}{(o\\cdot n)(m\\cdot n)} \\end{aligned} $$ 这里暂且考虑所有能量都被反射，即 F 为 1；最后留在分子上的实际上是 $i\\cdot m$，但是 $i\\cdot m=o\\cdot m$，所以可以替换\n在 Emu_IS.cpp 的 IntegrateBRDF 函数中每次采样累加该权重即可：\n1Vec3f IntegrateBRDF(Vec3f V, float roughness) { 2 3 const int sample_count = 1024; 4 Vec3f N = Vec3f(0.0, 0.0, 1.0); 5 Vec3f Emu = Vec3f(0.0f); 6 for (int i = 0; i \u003c sample_count; i++) { 7 Vec2f Xi = Hammersley(i, sample_count); 8 Vec3f H = ImportanceSampleGGX(Xi, N, roughness); 9 Vec3f L = normalize(H * 2.0f * dot(V, H) - V); 10 11 float NoL = std::max(L.z, 0.0f); 12 float NoH = std::max(H.z, 0.0f); 13 float VoH = std::max(dot(V, H), 0.0f); 14 float NoV = std::max(dot(N, V), 0.0f); 15 16 // calculate (fr * ni) / p_o here - Bonus 1 17 float w = VoH * GeometrySmith(roughness,NoV,NoL)/(NoV*NoH); 18 Emu += Vec3f(w); 19 // Split Sum - Bonus 2 20 } 21 22 return Emu / sample_count; 23} 完成重要性采样之后得到的 $E(\\mu)$ 就没有噪点了：\n0x04 预积分 $E_{avg}$ 预积分 $E_{avg}$ 的过程比较简单，甚至因为 $E(\\mu),\\mu$ 都是定值直接返回 $2E(\\mu)\\mu$ 即可。\n1Vec3f IntegrateEmu(Vec3f V, float roughness, float NdotV, Vec3f Ei) { 2 return Ei * NdotV * 2.0f; 3 Vec3f Eavg = Vec3f(0.0f); 4 const int sample_count = 1024; 5 Vec3f N = Vec3f(0.0, 0.0, 1.0); 6 7 for (int i = 0; i \u003c sample_count; i++) 8 { 9 Vec2f Xi = Hammersley(i, sample_count); 10 Vec3f H = ImportanceSampleGGX(Xi, N, roughness); 11 Vec3f L = normalize(H * 2.0f * dot(V, H) - V); 12 13 float NoL = std::max(L.z, 0.0f); 14 float NoH = std::max(H.z, 0.0f); 15 float VoH = std::max(dot(V, H), 0.0f); 16 float NoV = std::max(dot(N, V), 0.0f); 17 18 // calculate Eavg here - Bonus 1 19 Eavg += Ei * NoV * 2.0f; 20 } 21 22 return Eavg / sample_count; 23} 求解 $E_{avg}$ 的过程仅依赖于采样到的 $E(\\mu)$ ，所以 Eavg_IS.cpp 和 E_avg_MC.cpp 的实现是一样的。\n运行程序可以得到这样一张 LUT：\n如果正确实现了 $E(\\mu)$ 的重要性采样，上图就会变得 Smooth 一点：\n0x05 实时渲染 Realtime Rendering PBR 材质的实现就不贴了，公式已经给出了，可以直接搬离线端的实现\n在实时端需要采样预积分的 $E(\\mu)$ 和 $E_{avg}$ 的 LUT，然后仍然是套公式计算能量守恒的 BRDF：\n$$ f_{r}=f_{micro}+f_{add}*f_{ms} $$ 在 MultiScatterBRDF 函数中，需要完成对 $f_{add},f_{ms}$ 的计算：\n$$ \\begin{aligned} f_{add}\u0026=\\frac{F_{avg}E_{avg}}{1-F_{avg}(1-E_{avg})}\\\\ f_{ms}(\\mu_{o},\\mu_{i})\u0026=\\frac{(1-E(\\mu_{o}))(1-E(\\mu_{i}))}{\\pi(1-E_{avg})} \\end{aligned} $$ 1vec3 MultiScatterBRDF(float NdotL, float NdotV) 2{ 3 vec3 albedo = pow(texture2D(uAlbedoMap, vTextureCoord).rgb, vec3(2.2)); 4 5 vec3 E_o = texture2D(uBRDFLut, vec2(NdotL, uRoughness)).xxx; 6 vec3 E_i = texture2D(uBRDFLut, vec2(NdotV, uRoughness)).xxx; 7 8 vec3 E_avg = texture2D(uEavgLut, vec2(0, uRoughness)).xxx; 9 // copper 10 vec3 edgetint = vec3(0.827, 0.792, 0.678); 11 vec3 F_avg = AverageFresnel(albedo, edgetint); 12 13 // calculate fms and missing energy here 14 vec3 f_add = F_avg * E_avg / (1.0 - F_avg * (1.0 - E_avg)); 15 vec3 f_ms = (1.0 - E_o) * (1.0 - E_i) / (PI * (1.0 - E_avg)); 16 return f_add*f_ms; 17 18} 完成后即可达到如图所示的效果：\n0x06 Split Sum 仍然是计算 $E(\\mu)$，结果保存到一张与 roughness 和曲率相关的 LUT 中，我们可以把 F 项从 BRDF 中分离出来（这个思路在 Lecture5 Real-time Environment Mapping 1h 15min 左右有提及）：\n$$ \\begin{aligned} E\u0026=\\int_{\\Omega^+}f_{r}(n\\cdot i) d\\omega_{i} \\\\ \u0026=\\int_{\\Omega^+} \\frac{f_{r}}{F}(n\\cdot i) Fd\\omega_{i}\\\\ \u0026=\\int_{\\Omega^+} \\frac{f_{r}}{F}(n\\cdot i) (F_{0}+(1-F_{0})(1-\\cos \\theta)^5)d\\omega_{i}\\\\ \u0026=\\int_{\\Omega^+} \\frac{f_{r}}{F}(n\\cdot i) (F_{0}+(1-F_{0})\\alpha)d\\omega_{i}\\\\ \u0026=\\int_{\\Omega^+} \\frac{f_{r}}{F}(n\\cdot i) (F_{0}(1-\\alpha)+\\alpha)d\\omega_{i}\\\\ \u0026=F_{0}\\int_{\\Omega^+} \\frac{f_{r}}{F}(n\\cdot i) (1-\\alpha)d\\omega_{i}+\\int_{\\Omega^+} \\frac{f_{r}}{F}(n\\cdot i) \\alpha d\\omega_{i} \\end{aligned} $$ 记 $\\alpha=(1-\\cos \\theta)^5$\n更改一下 IntegrateBRDF，将这两个 Split 的结果分别存入 LUT 的 GB 通道，R 通道仍然存原来的 $E(\\mu)$：\n然后在实时端重载一个 MultiScatterBRDF，增加一个 F0 作为参数，用两个 Split 的积分还原 $E(\\mu),E_{avg}$：\n调用这个新的函数并传入 F0 即可看到使用 Split Sum 计算出来的结果：\n","wordCount":"1187","inLanguage":"zh","datePublished":"2025-06-14T00:00:00Z","dateModified":"2025-06-14T00:00:00Z","author":{"@type":"Person","name":"The Only Problem"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://congyuxiaoyoudao.github.io/posts/assignments/games202-homework-4/"},"publisher":{"@type":"Organization","name":"The Only Problem's Blog","logo":{"@type":"ImageObject","url":"https://congyuxiaoyoudao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://congyuxiaoyoudao.github.io/ accesskey=h title="The Only Problem's Blog (Alt + H)">The Only Problem's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://congyuxiaoyoudao.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://congyuxiaoyoudao.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://congyuxiaoyoudao.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://congyuxiaoyoudao.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://congyuxiaoyoudao.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://congyuxiaoyoudao.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://congyuxiaoyoudao.github.io/posts/assignments/>Assignments</a></div><h1 class="post-title entry-hint-parent">Assignment 7. GAMES202 Homework 4</h1><div class=post-meta><span title='2025-06-14 00:00:00 +0000 UTC'>六月 14, 2025</span>&nbsp;·&nbsp;6 分钟&nbsp;·&nbsp;The Only Problem</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#0x00-to-begin-with aria-label="0x00 To begin with">0x00 To begin with</a></li><li><a href=#0x01-%e8%af%be%e7%a8%8b%e5%9b%9e%e9%a1%be-recap aria-label="0x01 课程回顾 Recap">0x01 课程回顾 Recap</a><ul><li><a href=#%e8%83%bd%e9%87%8f%e5%ae%88%e6%81%92%e7%9a%84-bsdf-energy-preserving-bsdfs aria-label="能量守恒的 BSDF Energy-Preserving BSDFs">能量守恒的 BSDF Energy-Preserving BSDFs</a></li><li><a href=#%e9%a2%9c%e8%89%b2%e8%a1%a8%e9%9d%a2-colored-surfaces aria-label="颜色表面 Colored Surfaces">颜色表面 Colored Surfaces</a></li></ul></li><li><a href=#0x02-%e9%97%ae%e9%a2%98%e4%bf%ae%e5%a4%8d-troubleshooting aria-label="0x02 问题修复 TroubleShooting">0x02 问题修复 TroubleShooting</a></li><li><a href=#0x03-%e9%a2%84%e7%a7%af%e5%88%86-emu aria-label="0x03 预积分 $E(\mu)$">0x03 预积分 $E(\mu)$</a><ul><li><a href=#%e8%92%99%e7%89%b9%e5%8d%a1%e6%b4%9b%e6%b1%82%e8%a7%a3-monte-carlo aria-label="蒙特卡洛求解 Monte Carlo">蒙特卡洛求解 Monte Carlo</a></li><li><a href=#%e9%87%8d%e8%a6%81%e6%80%a7%e9%87%87%e6%a0%b7%e6%b1%82%e8%a7%a3-importance-sampling aria-label="重要性采样求解 Importance Sampling">重要性采样求解 Importance Sampling</a></li></ul></li><li><a href=#0x04-%e9%a2%84%e7%a7%af%e5%88%86-e_avg aria-label="0x04 预积分 $E_{avg}$">0x04 预积分 $E_{avg}$</a></li><li><a href=#0x05-%e5%ae%9e%e6%97%b6%e6%b8%b2%e6%9f%93-realtime-rendering aria-label="0x05 实时渲染 Realtime Rendering">0x05 实时渲染 Realtime Rendering</a></li><li><a href=#0x06-split-sum aria-label="0x06 Split Sum">0x06 Split Sum</a></li></ul></div></details></div><div class=post-content><blockquote><p>好久不见！最近在忙别的工作，这几天难得有时间，赶紧把 202 系列作业做个收尾ε٩(๑> ₃ &lt;)۶з！</p></blockquote><hr><h2 id=0x00-to-begin-with>0x00 To begin with<a hidden class=anchor aria-hidden=true href=#0x00-to-begin-with>#</a></h2><p>这篇文章将会包含以下内容：</p><ul><li><input checked disabled type=checkbox> 部分课程内容回顾</li><li><input checked disabled type=checkbox> GAMES202 作业 4</li></ul><p><strong>For reference</strong>👇：</p><ul><li>📺B 站视频：
<a href="https://www.bilibili.com/video/BV1YK4y1T7yY/?spm_id_from=333.337.top_right_bar_window_custom_collection.content.click&amp;vd_source=b6584cebba3a7a1a34d2f60d63bdc868">GAMES202-高质量实时渲染</a></li><li>📦代码仓库：
<a href=https://github.com/congyuxiaoyoudao/GAMES202_Homework/tree/working>congyuxiaoyoudao/GAMES202_Homework at working</a></li><li>📃
<a href=https://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_slides_v2.pdf>Revisiting Physically Based Shading at Imageworks</a></li></ul><blockquote><p>master 分支上是 202 全部作业汇总，working 分支用于提交代码。需要原始作业可下载 master 分支的包</p></blockquote><hr><h2 id=0x01-课程回顾-recap>0x01 课程回顾 Recap<a hidden class=anchor aria-hidden=true href=#0x01-课程回顾-recap>#</a></h2><h3 id=能量守恒的-bsdf-energy-preserving-bsdfs>能量守恒的 BSDF Energy-Preserving BSDFs<a hidden class=anchor aria-hidden=true href=#能量守恒的-bsdf-energy-preserving-bsdfs>#</a></h3><p>Cook-Torrance 提出的微表面 BRDF 只考虑光线在表面经过一次弹射后出射到观察方向的能量，然而忽略了多次弹射最终出射到观察方向的能量，这就造成了能量损失。尤其是当材质的 roughness 较高时，G 项减小，多次弹射的比例增加，能量损失越严重。</p><p><img alt="Missing Energy of Microfacet BRDF, Revisiting Physically Based Shading at Imageworks, SIGGRAPH 2017" loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%207.GAMES202HW4/202506151740381.png#center></p><p>2017 年 Kulla 和 Conty 受到 Disney Principle BRDF 的启发，提出了一种改进的方法，即通过引入一个能量补偿项，将多次弹射出射到观察方向的能量补充回来，就能近似地保持能量守恒。</p><p>有了渲染方程，我们可以很容易地求得微表面 BRDF 在观察方向 $\mu_{o}$ 上出射的总能量：</p><div>$$
E(\mu_{o})=\int_{0}^{2\pi}\int_{0}^{1}f(\mu_{o},\mu_{i},\phi)\mu_{i}d\mu_{i}d\phi
$$</div><blockquote><p>这里记 $\mu_{i}=\sin \theta,\theta=n\cdot \mu_{i}$，之后就可以将 $f_{r}\cos \theta \sin \theta d\theta d\phi$ 写为 $f_{r}\mu_{i} d\mu_{i}d\phi$。然而原 PPT 里提到的是记为 $\cos \theta$，不过就积分结果来说都一样</p></blockquote><p>$E(\mu_{o})$ 的范围为 0-1，对于不同的 $\mu_{o}$，$E(\mu_{o})$ 的值也会发生变化。微表面 BRDF 的 $E(\mu_{o})$ 会随着 roughness 的增加而衰减。为了弥补这部分能量，Kulla 和 Conty 设计了一个新的 BRDF lobe：</p><div>$$
f_{ms}=\frac{(1-E(\mu_{o}))(1-E(\mu_{i}))}{\pi(1-E_{avg})},E_{avg}=2\int_{0}^1E(\mu)\mu d\mu
$$</div><p>其中 $f_{ms}$ 为弥补损失的 BRDF，$E_{avg}$ 为在所有观察方向下出射能量的平均值。同样计算这个 BRDF 在观察方向 $\mu_{o}$ 上的积分：</p><div>$$
\begin{aligned}
E_{ms}(\mu_{o})&=\int_{0}^{2\pi}\int_{0}^{1}f_{ms}(\mu_{o},\mu_{i},\phi)\mu_{i}d\mu_{i}d\phi \\
&=2 \int_{0}^1 \frac{(1-E(\mu_{o}))(1-E(\mu_{i}))}{\pi(1-E_{avg})}\mu_{i}d\mu_{i}\\
&=2 \frac{1-E(\mu_{o})}{1-E_{avg}}\int_{0}^1(1-E(\mu_{i}))\mu_{i}d\mu_{i}\\
&= \frac{1-E(\mu_{o})}{1-E_{avg}}(1-E_{avg})\\
&= 1-E(\mu_{o})
\end{aligned}
$$</div><p>将其加到原来的微表面 BRDF 上即可弥补损失：</p><div>$$
E(\mu_{o})+E_{ms}(\mu_{o})\equiv 1
$$</div><p><img alt="Micro Energy Compensation, Revisiting Physically Based Shading at Imageworks, SIGGRAPH 2017" loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%207.GAMES202HW4/202506151914803.png#center></p><p>计算 $E(\mu)$ 和 $E_{avg}$ 都需要积分，我们可以在离线端预先计算好这两项，将其按需要的变量打表，存储在纹理上，然后渲染时对应查询即可。PPT 中指出 32×32 的大小的纹理就足够了，作业中则使用了更大的 128×128。</p><h3 id=颜色表面-colored-surfaces>颜色表面 Colored Surfaces<a hidden class=anchor aria-hidden=true href=#颜色表面-colored-surfaces>#</a></h3><p>在上一节中，表面将所有入射的光全部反射，即光线不存在被吸收或者透射的情况。然而，绝大多数表面是带有颜色的，即其会吸收某种成分的光，这种情况下的能量损失是符合物理的，即 $E(\mu)&lt;1$。</p><p>Kulla 和 Conty 受到 Jakob 等人的启发，多次弹射下能量是 diffuse 的，所以可以使用余弦加权的 Fresnel 项代表平均被反射的能量：</p><div>$$
F_{avg}=2\int_{0}^1F(\mu)\mu d\mu
$$</div><p>我们已经知道所有反射出射的能量比例为 $E_{avg}$，那么因为微表面的遮挡而没有出射的能量比例则为 $1-E_{avg}$，这部分能量（即发生了二次 bounce）中又有 $F_{avg}$ 的比例能够被反射，所以经过 $n$ 次反射出射到观察方向的能量可以归纳为：</p><div>$$
\begin{aligned}
E_{0}&=F_{avg}E_{avg}\\
E_{1}&=F_{avg}(1-E_{avg})F_{avg}E_{avg}\\
\dots\\
E_{n}&=F_{avg}^n (1-E_{avg})^n F_{avg}E_{avg}
\end{aligned}
$$</div><p>很显然这是一个等比数列，将其求和后即可得到所有经过多次弹射最终出射到观察方向的总能量：</p><div>$$
E=F_{avg}E_{avg}\sum_{k=0}^{\infty}F_{avg}^k(1-E_{avg})^k=\frac{F_{avg}E_{avg}}{1-F_{avg}(1-E_{avg})}
$$</div><p>$E_{avg}$ 可以通过预计算得到，但是 $F_{avg}$ 无法这么做。所以 Kulla 和 Conty 分别对介电质和导体列出了两种前人用到的数值近似方法：</p><p><img alt="Dielectric Fresnel, Revisiting Physically Based Shading at Imageworks, SIGGRAPH 2017" loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%207.GAMES202HW4/202506152010539.png#center></p><p><img alt="Conductor Fresnel, Revisiting Physically Based Shading at Imageworks, SIGGRAPH 2017" loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%207.GAMES202HW4/202506152011189.png#center></p><p>如此，在渲染时即可采样 $E_{avg}$ 和根据表面性质近似 $F_{avg}$ 计算出颜色表面的出射能量比例，然后再将其与上节中没有能量吸收的 $f_{ms}$ 相乘即可。</p><hr><h2 id=0x02-问题修复-troubleshooting>0x02 问题修复 TroubleShooting<a hidden class=anchor aria-hidden=true href=#0x02-问题修复-troubleshooting>#</a></h2><p>做作业时遇到一些出现问题的地方，这里一并提一下：</p><ol><li>找不到 vec.h</li><li>未定义标识符“<code>M_PI</code>”</li><li>uniform 变量 <code>uEavgFLut</code> 命名错误</li></ol><p>第一个问题是配置问题，用 vscode 在 task.json 的 args 字段加上：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=ln>1</span><span class=cl> <span class=s2>&#34;-I&#34;</span><span class=err>,</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=s2>&#34;${workspaceFolder}/assignment4/lut-gen/ext&#34;</span><span class=err>,</span>
</span></span></code></pre></div><p>第二个问题把所有 <code>M_PI</code> 改成 <code>PI</code>。</p><p>第三个问题在 KullaContyMaterial.js 中，调用父类构造函数时传入了命名和 Shader 中不对应的 uniform 变量，把 <code>uEavgFLut</code> 改成 <code>uEavgLut</code> 即可。</p><hr><h2 id=0x03-预积分-emu>0x03 预积分 $E(\mu)$<a hidden class=anchor aria-hidden=true href=#0x03-预积分-emu>#</a></h2><h3 id=蒙特卡洛求解-monte-carlo>蒙特卡洛求解 Monte Carlo<a hidden class=anchor aria-hidden=true href=#蒙特卡洛求解-monte-carlo>#</a></h3><p>在 Emu_MC.cpp 的 <code>IntegrateBRDF</code> 中完成对 $E(\mu)$ 的积分，使用蒙特卡洛方法在半球上均匀采样入射光方向，求解这个积分。积分内部为 BRDF 以及 cos 项：</p><div>$$
f_{r}(i,o)=\frac{F(i,h)G(i,o,h)D(h)}{4(n\cdot i)(n\cdot o)},\cos \theta=n\cdot i
$$</div><p>F，G，D 的实现框架中均已给出，按需调用即可。</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%207.GAMES202HW4/202506152027150.png#center></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=ln> 1</span><span class=cl><span class=n>Vec3f</span> <span class=nf>IntegrateBRDF</span><span class=p>(</span><span class=n>Vec3f</span> <span class=n>V</span><span class=p>,</span> <span class=kt>float</span> <span class=n>roughness</span><span class=p>,</span> <span class=kt>float</span> <span class=n>NdotV</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>    <span class=kt>float</span> <span class=n>A</span> <span class=o>=</span> <span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>    <span class=kt>float</span> <span class=n>B</span> <span class=o>=</span> <span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>    <span class=kt>float</span> <span class=n>C</span> <span class=o>=</span> <span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>sample_count</span> <span class=o>=</span> <span class=mi>1024</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    <span class=n>Vec3f</span> <span class=n>N</span> <span class=o>=</span> <span class=n>Vec3f</span><span class=p>(</span><span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>    
</span></span><span class=line><span class=ln> 8</span><span class=cl>    <span class=n>samplePoints</span> <span class=n>sampleList</span> <span class=o>=</span> <span class=n>squareToCosineHemisphere</span><span class=p>(</span><span class=n>sample_count</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>sample_count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>      <span class=c1>// calculate (fr * ni) / p_o here
</span></span></span><span class=line><span class=ln>11</span><span class=cl><span class=c1></span>      <span class=n>Vec3f</span> <span class=n>L</span> <span class=o>=</span> <span class=n>sampleList</span><span class=p>.</span><span class=n>directions</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>      <span class=kt>float</span> <span class=n>pdf</span> <span class=o>=</span> <span class=n>sampleList</span><span class=p>.</span><span class=n>PDFs</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>
</span></span><span class=line><span class=ln>14</span><span class=cl>      <span class=kt>float</span> <span class=n>NdotL</span> <span class=o>=</span> <span class=n>dot</span><span class=p>(</span><span class=n>N</span><span class=p>,</span><span class=n>L</span><span class=p>);</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>      <span class=n>Vec3f</span> <span class=n>H</span> <span class=o>=</span> <span class=n>normalize</span><span class=p>(</span><span class=n>V</span><span class=o>+</span><span class=n>L</span><span class=p>);</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>
</span></span><span class=line><span class=ln>17</span><span class=cl>      <span class=c1>// here we assume all lights are reflected, no absorption!
</span></span></span><span class=line><span class=ln>18</span><span class=cl><span class=c1></span>      <span class=c1>// deal with color later
</span></span></span><span class=line><span class=ln>19</span><span class=cl><span class=c1></span>      <span class=kt>float</span> <span class=n>F</span> <span class=o>=</span> <span class=mf>1.0</span><span class=p>;</span>
</span></span><span class=line><span class=ln>20</span><span class=cl>      <span class=kt>float</span> <span class=n>NDF</span> <span class=o>=</span> <span class=n>DistributionGGX</span><span class=p>(</span><span class=n>N</span><span class=p>,</span> <span class=n>H</span><span class=p>,</span> <span class=n>roughness</span><span class=p>);</span>
</span></span><span class=line><span class=ln>21</span><span class=cl>      <span class=kt>float</span> <span class=n>G</span> <span class=o>=</span> <span class=n>GeometrySmith</span><span class=p>(</span><span class=n>roughness</span><span class=p>,</span> <span class=n>NdotV</span><span class=p>,</span> <span class=n>NdotL</span><span class=p>);</span>
</span></span><span class=line><span class=ln>22</span><span class=cl>
</span></span><span class=line><span class=ln>23</span><span class=cl>      <span class=kt>float</span> <span class=n>nom</span> <span class=o>=</span> <span class=n>F</span> <span class=o>*</span> <span class=n>NDF</span> <span class=o>*</span> <span class=n>G</span><span class=p>;</span>
</span></span><span class=line><span class=ln>24</span><span class=cl>      <span class=kt>float</span> <span class=n>denom</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=p>(</span><span class=mf>4.0</span> <span class=o>*</span> <span class=n>NdotL</span> <span class=o>*</span> <span class=n>NdotV</span><span class=p>,</span><span class=mf>0.001</span><span class=p>);</span>
</span></span><span class=line><span class=ln>25</span><span class=cl>      <span class=kt>float</span> <span class=n>fr</span> <span class=o>=</span> <span class=n>nom</span> <span class=o>/</span> <span class=n>denom</span><span class=p>;</span>
</span></span><span class=line><span class=ln>26</span><span class=cl>
</span></span><span class=line><span class=ln>27</span><span class=cl>      <span class=c1>// accumulate each component
</span></span></span><span class=line><span class=ln>28</span><span class=cl><span class=c1></span>      <span class=n>A</span> <span class=o>=</span> <span class=n>B</span> <span class=o>=</span> <span class=n>C</span> <span class=o>+=</span><span class=n>fr</span><span class=o>*</span><span class=n>NdotL</span><span class=o>/</span><span class=n>pdf</span><span class=p>;</span>
</span></span><span class=line><span class=ln>29</span><span class=cl>
</span></span><span class=line><span class=ln>30</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>31</span><span class=cl>
</span></span><span class=line><span class=ln>32</span><span class=cl>    <span class=k>return</span> <span class=p>{</span><span class=n>A</span> <span class=o>/</span> <span class=n>sample_count</span><span class=p>,</span> <span class=n>B</span> <span class=o>/</span> <span class=n>sample_count</span><span class=p>,</span> <span class=n>C</span> <span class=o>/</span> <span class=n>sample_count</span><span class=p>};</span>
</span></span><span class=line><span class=ln>33</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>运行程序即可得到这样一张 LUT：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%207.GAMES202HW4/202506152042227.png#center></p><p>可以看到随着粗糙度降低（自上而下），噪声越来越明显。这是因为低粗糙度的微表面法线 $m$ 集中在宏观法线 $n$ 附近，但通过随机采样入射光方向 $i$ 计算得到的半程向量 $h$ 则不然，因此导致低粗糙度下积分值的方差显著增加。但我们可以通过对微表面法线 $m$ 进行重要性采样来改善这个问题，即使得采样的 $m$ 更多地位于 $n$ 附近。</p><h3 id=重要性采样求解-importance-sampling>重要性采样求解 Importance Sampling<a hidden class=anchor aria-hidden=true href=#重要性采样求解-importance-sampling>#</a></h3><p>最终的任务仍然是采样 $i$ 和计算 $\frac{f_{r}(i,o,h)(i,n)}{pdf_{i}(i)}$，但现在 $i$ 并不由直接采样得到，而是根据某个微表面法线分布模型重要性采样得到的微表面法向 $m$ 间接求解。</p><p>框架中使用的 NDF 为 GGX 分布，我们需要根据该分布生成采样的微表面法向 $m$，再由 $m$ 和 $o$ 反求入射方向 $i$。</p><p>由微表面法线分布模型的性质，可以计算出采样 $m$ 的概率密度：</p><div>$$
pdf_{m}(m)=D(m)(m\cdot n)
$$</div><p>通过该概率密度，可以计算出该分布下对应的采样点：</p><div>$$
\begin{aligned}
\theta_{m}&=\arctan\left( \frac{\alpha \sqrt{ \xi_{1} }}{\sqrt{ 1-\xi_{1} }} \right)\\
\phi_{h}&=2\pi \xi_{2}
\end{aligned}
$$</div><p>其中，$\alpha=roughness^{2},\xi_{1},\xi_{2}\in[0,1)$。</p><p>在 Emu_IS.cpp 的 <code>ImportanceSampleGGX</code> 函数中，完成重要性采样的逻辑，并返回切线空间的微表面法线 $h$。</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%207.GAMES202HW4/202506152111744.png#center></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=ln> 1</span><span class=cl><span class=n>Vec3f</span> <span class=nf>ImportanceSampleGGX</span><span class=p>(</span><span class=n>Vec2f</span> <span class=n>Xi</span><span class=p>,</span> <span class=n>Vec3f</span> <span class=n>N</span><span class=p>,</span> <span class=kt>float</span> <span class=n>roughness</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>    <span class=kt>float</span> <span class=n>a</span> <span class=o>=</span> <span class=n>roughness</span> <span class=o>*</span> <span class=n>roughness</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>
</span></span><span class=line><span class=ln> 4</span><span class=cl>    <span class=c1>// in spherical space - Bonus 1
</span></span></span><span class=line><span class=ln> 5</span><span class=cl><span class=c1></span>    <span class=kt>float</span> <span class=n>Xi1</span> <span class=o>=</span> <span class=n>Xi</span><span class=p>.</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    <span class=kt>float</span> <span class=n>Xi2</span> <span class=o>=</span> <span class=n>Xi</span><span class=p>.</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>    <span class=kt>float</span> <span class=n>theta</span> <span class=o>=</span> <span class=n>atan</span><span class=p>(</span><span class=n>a</span><span class=o>*</span><span class=n>sqrt</span><span class=p>(</span><span class=n>Xi1</span><span class=p>)</span><span class=o>/</span><span class=n>sqrt</span><span class=p>(</span><span class=mi>1</span><span class=o>-</span><span class=n>Xi1</span><span class=p>));</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>    <span class=kt>float</span> <span class=n>phi</span> <span class=o>=</span> <span class=mf>2.0</span> <span class=o>*</span> <span class=n>PI</span> <span class=o>*</span> <span class=n>Xi2</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>
</span></span><span class=line><span class=ln>10</span><span class=cl>    <span class=c1>// from spherical space to cartesian space - Bonus 1
</span></span></span><span class=line><span class=ln>11</span><span class=cl><span class=c1></span>    <span class=kt>float</span> <span class=n>x</span> <span class=o>=</span> <span class=n>cos</span><span class=p>(</span><span class=n>phi</span><span class=p>)</span><span class=o>*</span><span class=n>sin</span><span class=p>(</span><span class=n>theta</span><span class=p>);</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>    <span class=kt>float</span> <span class=n>y</span> <span class=o>=</span> <span class=n>sin</span><span class=p>(</span><span class=n>phi</span><span class=p>)</span><span class=o>*</span><span class=n>sin</span><span class=p>(</span><span class=n>theta</span><span class=p>);</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>    <span class=kt>float</span> <span class=n>z</span> <span class=o>=</span> <span class=n>cos</span><span class=p>(</span><span class=n>theta</span><span class=p>);</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>
</span></span><span class=line><span class=ln>15</span><span class=cl>    <span class=c1>// tangent coordinates - Bonus 1
</span></span></span><span class=line><span class=ln>16</span><span class=cl><span class=c1></span>    <span class=n>Vec3f</span> <span class=n>up</span> <span class=o>=</span> <span class=n>abs</span><span class=p>(</span><span class=n>N</span><span class=p>.</span><span class=n>z</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mf>0.999</span> <span class=o>?</span> <span class=n>Vec3f</span><span class=p>(</span><span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>)</span> <span class=o>:</span> <span class=n>Vec3f</span><span class=p>(</span><span class=mf>1.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>);</span> <span class=c1>// N is fixed 001 so not select 001
</span></span></span><span class=line><span class=ln>17</span><span class=cl><span class=c1></span>    <span class=n>Vec3f</span> <span class=n>tangent</span> <span class=o>=</span> <span class=n>normalize</span><span class=p>(</span><span class=n>cross</span><span class=p>(</span><span class=n>up</span><span class=p>,</span><span class=n>N</span><span class=p>));</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>    <span class=n>Vec3f</span> <span class=n>bitangent</span> <span class=o>=</span> <span class=n>cross</span><span class=p>(</span><span class=n>N</span><span class=p>,</span><span class=n>tangent</span><span class=p>);</span>
</span></span><span class=line><span class=ln>19</span><span class=cl>
</span></span><span class=line><span class=ln>20</span><span class=cl>    <span class=c1>// transform H to tangent space - Bonus 1
</span></span></span><span class=line><span class=ln>21</span><span class=cl><span class=c1></span>    <span class=n>Vec3f</span> <span class=n>H</span> <span class=o>=</span> <span class=n>normalize</span><span class=p>(</span><span class=n>tangent</span><span class=o>*</span><span class=n>x</span> <span class=o>+</span> <span class=n>bitangent</span><span class=o>*</span><span class=n>y</span> <span class=o>+</span> <span class=n>N</span><span class=o>*</span><span class=n>z</span><span class=p>);</span>
</span></span><span class=line><span class=ln>22</span><span class=cl>    <span class=k>return</span> <span class=n>H</span><span class=p>;</span>
</span></span><span class=line><span class=ln>23</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>接下来计算 $\frac{f_{r}(i,o,h)(i,n)}{pdf_{i}(i)}$ 的值，需要先将采样 $m$ 的概率密度转化为采样 $i$ 的概率密度：</p><div>$$
pdf_{i}(i)=pdf_{m}(m)\left\lvert \left\lvert \frac{\partial\omega_{m}}{\partial \omega_{i}} \right\rvert \right\rvert =\frac{D(m)(m\cdot n)}{4(i\cdot m)}
$$</div><p>所以最终需要累加的权重为：</p><div>$$
\begin{aligned}
weight(i)&=\frac{f_{r}(i,o,h)(i,n)}{pdf_{i}(i)} \\
&=\frac{F(i,m)G(i,o,m)D(m)}{4(n\cdot i)(n\cdot o)}\cdot(n\cdot i)\cdot \frac{4(i\cdot m)}{D(m)(n\cdot m)} \\
&=\frac{(o\cdot m)G(i,o,h)}{(o\cdot n)(m\cdot n)}
\end{aligned}
$$</div><blockquote><p>这里暂且考虑所有能量都被反射，即 F 为 1；最后留在分子上的实际上是 $i\cdot m$，但是 $i\cdot m=o\cdot m$，所以可以替换</p></blockquote><p>在 Emu_IS.cpp 的 <code>IntegrateBRDF</code> 函数中每次采样累加该权重即可：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=ln> 1</span><span class=cl><span class=n>Vec3f</span> <span class=nf>IntegrateBRDF</span><span class=p>(</span><span class=n>Vec3f</span> <span class=n>V</span><span class=p>,</span> <span class=kt>float</span> <span class=n>roughness</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>
</span></span><span class=line><span class=ln> 3</span><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>sample_count</span> <span class=o>=</span> <span class=mi>1024</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>    <span class=n>Vec3f</span> <span class=n>N</span> <span class=o>=</span> <span class=n>Vec3f</span><span class=p>(</span><span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>    <span class=n>Vec3f</span> <span class=n>Emu</span> <span class=o>=</span> <span class=n>Vec3f</span><span class=p>(</span><span class=mf>0.0f</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>sample_count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>        <span class=n>Vec2f</span> <span class=n>Xi</span> <span class=o>=</span> <span class=n>Hammersley</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>sample_count</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>        <span class=n>Vec3f</span> <span class=n>H</span> <span class=o>=</span> <span class=n>ImportanceSampleGGX</span><span class=p>(</span><span class=n>Xi</span><span class=p>,</span> <span class=n>N</span><span class=p>,</span> <span class=n>roughness</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>        <span class=n>Vec3f</span> <span class=n>L</span> <span class=o>=</span> <span class=n>normalize</span><span class=p>(</span><span class=n>H</span> <span class=o>*</span> <span class=mf>2.0f</span> <span class=o>*</span> <span class=n>dot</span><span class=p>(</span><span class=n>V</span><span class=p>,</span> <span class=n>H</span><span class=p>)</span> <span class=o>-</span> <span class=n>V</span><span class=p>);</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>
</span></span><span class=line><span class=ln>11</span><span class=cl>        <span class=kt>float</span> <span class=n>NoL</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=p>(</span><span class=n>L</span><span class=p>.</span><span class=n>z</span><span class=p>,</span> <span class=mf>0.0f</span><span class=p>);</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>        <span class=kt>float</span> <span class=n>NoH</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=p>(</span><span class=n>H</span><span class=p>.</span><span class=n>z</span><span class=p>,</span> <span class=mf>0.0f</span><span class=p>);</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>        <span class=kt>float</span> <span class=n>VoH</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=p>(</span><span class=n>dot</span><span class=p>(</span><span class=n>V</span><span class=p>,</span> <span class=n>H</span><span class=p>),</span> <span class=mf>0.0f</span><span class=p>);</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>        <span class=kt>float</span> <span class=n>NoV</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=p>(</span><span class=n>dot</span><span class=p>(</span><span class=n>N</span><span class=p>,</span> <span class=n>V</span><span class=p>),</span> <span class=mf>0.0f</span><span class=p>);</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>        
</span></span><span class=line><span class=ln>16</span><span class=cl>        <span class=c1>// calculate (fr * ni) / p_o here - Bonus 1
</span></span></span><span class=line><span class=ln>17</span><span class=cl><span class=c1></span>        <span class=kt>float</span> <span class=n>w</span> <span class=o>=</span> <span class=n>VoH</span> <span class=o>*</span> <span class=n>GeometrySmith</span><span class=p>(</span><span class=n>roughness</span><span class=p>,</span><span class=n>NoV</span><span class=p>,</span><span class=n>NoL</span><span class=p>)</span><span class=o>/</span><span class=p>(</span><span class=n>NoV</span><span class=o>*</span><span class=n>NoH</span><span class=p>);</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>        <span class=n>Emu</span> <span class=o>+=</span> <span class=n>Vec3f</span><span class=p>(</span><span class=n>w</span><span class=p>);</span>
</span></span><span class=line><span class=ln>19</span><span class=cl>        <span class=c1>// Split Sum - Bonus 2
</span></span></span><span class=line><span class=ln>20</span><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=ln>21</span><span class=cl>
</span></span><span class=line><span class=ln>22</span><span class=cl>    <span class=k>return</span> <span class=n>Emu</span> <span class=o>/</span> <span class=n>sample_count</span><span class=p>;</span>
</span></span><span class=line><span class=ln>23</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>完成重要性采样之后得到的 $E(\mu)$ 就没有噪点了：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%207.GAMES202HW4/202506152305671.png#center></p><hr><h2 id=0x04-预积分-e_avg>0x04 预积分 $E_{avg}$<a hidden class=anchor aria-hidden=true href=#0x04-预积分-e_avg>#</a></h2><p>预积分 $E_{avg}$ 的过程比较简单，甚至因为 $E(\mu),\mu$ 都是定值直接返回 $2E(\mu)\mu$ 即可。</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%207.GAMES202HW4/202506152251191.png#center></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=ln> 1</span><span class=cl><span class=n>Vec3f</span> <span class=nf>IntegrateEmu</span><span class=p>(</span><span class=n>Vec3f</span> <span class=n>V</span><span class=p>,</span> <span class=kt>float</span> <span class=n>roughness</span><span class=p>,</span> <span class=kt>float</span> <span class=n>NdotV</span><span class=p>,</span> <span class=n>Vec3f</span> <span class=n>Ei</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>    <span class=k>return</span> <span class=n>Ei</span> <span class=o>*</span> <span class=n>NdotV</span> <span class=o>*</span> <span class=mf>2.0f</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>    <span class=n>Vec3f</span> <span class=n>Eavg</span> <span class=o>=</span> <span class=n>Vec3f</span><span class=p>(</span><span class=mf>0.0f</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>sample_count</span> <span class=o>=</span> <span class=mi>1024</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>    <span class=n>Vec3f</span> <span class=n>N</span> <span class=o>=</span> <span class=n>Vec3f</span><span class=p>(</span><span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>
</span></span><span class=line><span class=ln> 7</span><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>sample_count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> 
</span></span><span class=line><span class=ln> 8</span><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>        <span class=n>Vec2f</span> <span class=n>Xi</span> <span class=o>=</span> <span class=n>Hammersley</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>sample_count</span><span class=p>);</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>        <span class=n>Vec3f</span> <span class=n>H</span> <span class=o>=</span> <span class=n>ImportanceSampleGGX</span><span class=p>(</span><span class=n>Xi</span><span class=p>,</span> <span class=n>N</span><span class=p>,</span> <span class=n>roughness</span><span class=p>);</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>        <span class=n>Vec3f</span> <span class=n>L</span> <span class=o>=</span> <span class=n>normalize</span><span class=p>(</span><span class=n>H</span> <span class=o>*</span> <span class=mf>2.0f</span> <span class=o>*</span> <span class=n>dot</span><span class=p>(</span><span class=n>V</span><span class=p>,</span> <span class=n>H</span><span class=p>)</span> <span class=o>-</span> <span class=n>V</span><span class=p>);</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>
</span></span><span class=line><span class=ln>13</span><span class=cl>        <span class=kt>float</span> <span class=n>NoL</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=p>(</span><span class=n>L</span><span class=p>.</span><span class=n>z</span><span class=p>,</span> <span class=mf>0.0f</span><span class=p>);</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>        <span class=kt>float</span> <span class=n>NoH</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=p>(</span><span class=n>H</span><span class=p>.</span><span class=n>z</span><span class=p>,</span> <span class=mf>0.0f</span><span class=p>);</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>        <span class=kt>float</span> <span class=n>VoH</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=p>(</span><span class=n>dot</span><span class=p>(</span><span class=n>V</span><span class=p>,</span> <span class=n>H</span><span class=p>),</span> <span class=mf>0.0f</span><span class=p>);</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>        <span class=kt>float</span> <span class=n>NoV</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=p>(</span><span class=n>dot</span><span class=p>(</span><span class=n>N</span><span class=p>,</span> <span class=n>V</span><span class=p>),</span> <span class=mf>0.0f</span><span class=p>);</span>
</span></span><span class=line><span class=ln>17</span><span class=cl>
</span></span><span class=line><span class=ln>18</span><span class=cl>        <span class=c1>// calculate Eavg here - Bonus 1
</span></span></span><span class=line><span class=ln>19</span><span class=cl><span class=c1></span>        <span class=n>Eavg</span> <span class=o>+=</span> <span class=n>Ei</span> <span class=o>*</span> <span class=n>NoV</span> <span class=o>*</span> <span class=mf>2.0f</span><span class=p>;</span>
</span></span><span class=line><span class=ln>20</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>21</span><span class=cl>
</span></span><span class=line><span class=ln>22</span><span class=cl>    <span class=k>return</span> <span class=n>Eavg</span> <span class=o>/</span> <span class=n>sample_count</span><span class=p>;</span>
</span></span><span class=line><span class=ln>23</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>求解 $E_{avg}$ 的过程仅依赖于采样到的 $E(\mu)$ ，所以 Eavg_IS.cpp 和 E_avg_MC.cpp 的实现是一样的。</p><p>运行程序可以得到这样一张 LUT：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%207.GAMES202HW4/202506152300734.png#center></p><p>如果正确实现了 $E(\mu)$ 的重要性采样，上图就会变得 Smooth 一点：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%207.GAMES202HW4/202506152305677.png#center></p><hr><h2 id=0x05-实时渲染-realtime-rendering>0x05 实时渲染 Realtime Rendering<a hidden class=anchor aria-hidden=true href=#0x05-实时渲染-realtime-rendering>#</a></h2><blockquote><p>PBR 材质的实现就不贴了，公式已经给出了，可以直接搬离线端的实现</p></blockquote><p>在实时端需要采样预积分的 $E(\mu)$ 和 $E_{avg}$ 的 LUT，然后仍然是套公式计算能量守恒的 BRDF：</p><div>$$
f_{r}=f_{micro}+f_{add}*f_{ms}
$$</div><p>在 <code>MultiScatterBRDF</code> 函数中，需要完成对 $f_{add},f_{ms}$ 的计算：</p><div>$$
\begin{aligned}
f_{add}&=\frac{F_{avg}E_{avg}}{1-F_{avg}(1-E_{avg})}\\
f_{ms}(\mu_{o},\mu_{i})&=\frac{(1-E(\mu_{o}))(1-E(\mu_{i}))}{\pi(1-E_{avg})}
\end{aligned}
$$</div><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%207.GAMES202HW4/202506152327799.png#center></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-glsl data-lang=glsl><span class=line><span class=ln> 1</span><span class=cl><span class=k>vec3</span> <span class=n>MultiScatterBRDF</span><span class=p>(</span><span class=k>float</span> <span class=n>NdotL</span><span class=p>,</span> <span class=k>float</span> <span class=n>NdotV</span><span class=p>)</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>  <span class=k>vec3</span> <span class=n>albedo</span> <span class=o>=</span> <span class=n>pow</span><span class=p>(</span><span class=n>texture2D</span><span class=p>(</span><span class=n>uAlbedoMap</span><span class=p>,</span> <span class=n>vTextureCoord</span><span class=p>).</span><span class=n>rgb</span><span class=p>,</span> <span class=k>vec3</span><span class=p>(</span><span class=mf>2.2</span><span class=p>));</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>
</span></span><span class=line><span class=ln> 5</span><span class=cl>  <span class=k>vec3</span> <span class=n>E_o</span> <span class=o>=</span> <span class=n>texture2D</span><span class=p>(</span><span class=n>uBRDFLut</span><span class=p>,</span> <span class=k>vec2</span><span class=p>(</span><span class=n>NdotL</span><span class=p>,</span> <span class=n>uRoughness</span><span class=p>)).</span><span class=n>xxx</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>  <span class=k>vec3</span> <span class=n>E_i</span> <span class=o>=</span> <span class=n>texture2D</span><span class=p>(</span><span class=n>uBRDFLut</span><span class=p>,</span> <span class=k>vec2</span><span class=p>(</span><span class=n>NdotV</span><span class=p>,</span> <span class=n>uRoughness</span><span class=p>)).</span><span class=n>xxx</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>
</span></span><span class=line><span class=ln> 8</span><span class=cl>  <span class=k>vec3</span> <span class=n>E_avg</span> <span class=o>=</span> <span class=n>texture2D</span><span class=p>(</span><span class=n>uEavgLut</span><span class=p>,</span> <span class=k>vec2</span><span class=p>(</span><span class=mo>0</span><span class=p>,</span> <span class=n>uRoughness</span><span class=p>)).</span><span class=n>xxx</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>  <span class=c1>// copper</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>  <span class=k>vec3</span> <span class=n>edgetint</span> <span class=o>=</span> <span class=k>vec3</span><span class=p>(</span><span class=mf>0.827</span><span class=p>,</span> <span class=mf>0.792</span><span class=p>,</span> <span class=mf>0.678</span><span class=p>);</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>  <span class=k>vec3</span> <span class=n>F_avg</span> <span class=o>=</span> <span class=n>AverageFresnel</span><span class=p>(</span><span class=n>albedo</span><span class=p>,</span> <span class=n>edgetint</span><span class=p>);</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>  
</span></span><span class=line><span class=ln>13</span><span class=cl>  <span class=c1>// calculate fms and missing energy here</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>  <span class=k>vec3</span> <span class=n>f_add</span> <span class=o>=</span> <span class=n>F_avg</span> <span class=o>*</span> <span class=n>E_avg</span> <span class=o>/</span> <span class=p>(</span><span class=mf>1.0</span> <span class=o>-</span> <span class=n>F_avg</span> <span class=o>*</span> <span class=p>(</span><span class=mf>1.0</span> <span class=o>-</span> <span class=n>E_avg</span><span class=p>));</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>  <span class=k>vec3</span> <span class=n>f_ms</span> <span class=o>=</span> <span class=p>(</span><span class=mf>1.0</span> <span class=o>-</span> <span class=n>E_o</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=mf>1.0</span> <span class=o>-</span> <span class=n>E_i</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=n>PI</span> <span class=o>*</span> <span class=p>(</span><span class=mf>1.0</span> <span class=o>-</span> <span class=n>E_avg</span><span class=p>));</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>  <span class=k>return</span> <span class=n>f_add</span><span class=o>*</span><span class=n>f_ms</span><span class=p>;</span>
</span></span><span class=line><span class=ln>17</span><span class=cl>  
</span></span><span class=line><span class=ln>18</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>完成后即可达到如图所示的效果：</p><p><img alt="上：Kulla-Conty BSDF 下：Microfacet BRDF" loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%207.GAMES202HW4/202506152348032.png#center></p><hr><h2 id=0x06-split-sum>0x06 Split Sum<a hidden class=anchor aria-hidden=true href=#0x06-split-sum>#</a></h2><p>仍然是计算 $E(\mu)$，结果保存到一张与 roughness 和曲率相关的 LUT 中，我们可以把 F 项从 BRDF 中分离出来（这个思路在 Lecture5 Real-time Environment Mapping 1h 15min 左右有提及）：</p><div>$$
\begin{aligned}
E&=\int_{\Omega^+}f_{r}(n\cdot i) d\omega_{i} \\
&=\int_{\Omega^+} \frac{f_{r}}{F}(n\cdot i) Fd\omega_{i}\\
&=\int_{\Omega^+} \frac{f_{r}}{F}(n\cdot i) (F_{0}+(1-F_{0})(1-\cos \theta)^5)d\omega_{i}\\
&=\int_{\Omega^+} \frac{f_{r}}{F}(n\cdot i) (F_{0}+(1-F_{0})\alpha)d\omega_{i}\\
&=\int_{\Omega^+} \frac{f_{r}}{F}(n\cdot i) (F_{0}(1-\alpha)+\alpha)d\omega_{i}\\
&=F_{0}\int_{\Omega^+} \frac{f_{r}}{F}(n\cdot i) (1-\alpha)d\omega_{i}+\int_{\Omega^+} \frac{f_{r}}{F}(n\cdot i) \alpha d\omega_{i}
\end{aligned}
$$</div><blockquote><p>记 $\alpha=(1-\cos \theta)^5$</p></blockquote><p>更改一下 <code>IntegrateBRDF</code>，将这两个 Split 的结果分别存入 LUT 的 GB 通道，R 通道仍然存原来的 $E(\mu)$：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%207.GAMES202HW4/202506152232914.png#center></p><p>然后在实时端重载一个 <code>MultiScatterBRDF</code>，增加一个 F0 作为参数，用两个 Split 的积分还原 $E(\mu),E_{avg}$：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%207.GAMES202HW4/202506160003257.png#center></p><p>调用这个新的函数并传入 F0 即可看到使用 Split Sum 计算出来的结果：</p><p><img alt="上：Split Sum 下：Microfacet BRDF" loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%207.GAMES202HW4/202506152350314.png#center></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://congyuxiaoyoudao.github.io/tags/games202/>GAMES202</a></li><li><a href=https://congyuxiaoyoudao.github.io/tags/brdf/>BRDF</a></li></ul><nav class=paginav><a class=next href=https://congyuxiaoyoudao.github.io/posts/assignments/games202-homework-3/><span class=title>下一页 »</span><br><span>Assignment 6. GAMES202 Homework 3</span></a></nav></footer><div id=tw-comment></div><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="light"?"light":"noborder_dark",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const s={src:"https://giscus.app/client.js","data-repo":"congyuxiaoyoudao/congyuxiaoyoudao.github.io","data-repo-id":"","data-category":"Announcements","data-category-id":"","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"","data-emit-metadata":"","data-input-position":"","data-theme":getStoredTheme(),"data-lang":"zh-CN","data-loading":"lazy",crossorigin:"anonymous"},e=document.createElement("script");Object.entries(s).forEach(([t,n])=>e.setAttribute(t,n)),document.querySelector("#tw-comment").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme);const n=document.querySelector("#theme-toggle-float");n&&n.addEventListener("click",setGiscusTheme)})</script></article></main><footer class=footer><span>&copy; 2025 <a href=https://congyuxiaoyoudao.github.io/>The Only Problem's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>