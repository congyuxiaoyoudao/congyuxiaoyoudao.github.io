<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The Only Problem's Blog</title><meta name=keywords content><meta name=description content="
不要忘记改图床上传地址！
Assignment系列：Assignments/Assignment 4.GAMES202HW1/









  Assignment 2. A Review of Realistic Water Waveform Simulation



🚩 0x00 To begin with
这篇文章将会包含以下内容：

 GAMES202 作业 1
 不包含作业框架分析

For reference👇：

📺 B 站视频：








  GAMES202-高质量实时渲染


📦 代码仓库：








  congyuxiaoyoudao/GAMES202_Homework at working




master 分支上是 202 全部作业汇总，working 分支用于提交代码。需要原始作业可下载 master 分支的包

0x01 Shadow Map
完成两个任务点：

第一个 Pass 以光源作为相机渲染一张 ShadowMap，需要为 Shader 传递正确的 uLightMVP 矩阵；
第二个 Pass 获取光源传递的统一变量 FBO （ShadowMap），需要比较当前 ShadingPoint 的深度值与 ShadowMap 上记录的深度值，得出可见性项与 Shading 结果相乘。

DirectionalLight.js 中，完善 CalcLightMVP 函数：

 1		// Model transform
 2        mat4.translate(modelMatrix, modelMatrix, translate);
 3        mat4.scale(modelMatrix, modelMatrix, scale);
 4
 5        // View transform
 6        mat4.lookAt(viewMatrix, this.lightPos, this.focalPoint, this.lightUp);
 7
 8        // Projection transform
 9        var r = 100;
10        var l = -r;
11        var t = 100;
12        var b = -t;
13        var n = 0.01;
14        // caution! Depth of far plane should be a bit more larger
15        var f = 400;
16        
17        mat4.ortho(projectionMatrix, l, r, b, t, n, f);

远平面需设置得稍微大一点，避免光源的视锥范围无法覆盖全部场景"><meta name=author content="The Only Problem"><link rel=canonical href=https://congyuxiaoyoudao.github.io/posts/assignments/assignment-4.-games202-homework-1/><link crossorigin=anonymous href=/assets/css/stylesheet.452758010f0b7fc9ad7fa528ffdfdd8eb9e830816fb8c8119f16f39583297db8.css integrity="sha256-RSdYAQ8Lf8mtf6Uo/9/djrnoMIFvuMgRnxbzlYMpfbg=" rel="preload stylesheet" as=style><link rel=icon href=https://congyuxiaoyoudao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://congyuxiaoyoudao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://congyuxiaoyoudao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://congyuxiaoyoudao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://congyuxiaoyoudao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://congyuxiaoyoudao.github.io/posts/assignments/assignment-4.-games202-homework-1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css integrity=sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js integrity=sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js integrity=sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk crossorigin=anonymous onload='window.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\$$",right:"\\\\$$",display:!1},{left:"\\$$",right:"\\\\$$",display:!0}]})})'></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdn.bootcdn.net/ajax/libs/lxgw-wenkai-screen-webfont/1.7.0/style.min.css><meta property="og:url" content="https://congyuxiaoyoudao.github.io/posts/assignments/assignment-4.-games202-homework-1/"><meta property="og:site_name" content="The Only Problem's Blog"><meta property="og:title" content="The Only Problem's Blog"><meta property="og:description" content=" 不要忘记改图床上传地址！ Assignment系列：Assignments/Assignment 4.GAMES202HW1/ Assignment 2. A Review of Realistic Water Waveform Simulation 🚩 0x00 To begin with 这篇文章将会包含以下内容：
GAMES202 作业 1 不包含作业框架分析 For reference👇：
📺 B 站视频： GAMES202-高质量实时渲染 📦 代码仓库： congyuxiaoyoudao/GAMES202_Homework at working master 分支上是 202 全部作业汇总，working 分支用于提交代码。需要原始作业可下载 master 分支的包
0x01 Shadow Map 完成两个任务点：
第一个 Pass 以光源作为相机渲染一张 ShadowMap，需要为 Shader 传递正确的 uLightMVP 矩阵； 第二个 Pass 获取光源传递的统一变量 FBO （ShadowMap），需要比较当前 ShadingPoint 的深度值与 ShadowMap 上记录的深度值，得出可见性项与 Shading 结果相乘。 DirectionalLight.js 中，完善 CalcLightMVP 函数：
1	// Model transform 2 mat4.translate(modelMatrix, modelMatrix, translate); 3 mat4.scale(modelMatrix, modelMatrix, scale); 4 5 // View transform 6 mat4.lookAt(viewMatrix, this.lightPos, this.focalPoint, this.lightUp); 7 8 // Projection transform 9 var r = 100; 10 var l = -r; 11 var t = 100; 12 var b = -t; 13 var n = 0.01; 14 // caution! Depth of far plane should be a bit more larger 15 var f = 400; 16 17 mat4.ortho(projectionMatrix, l, r, b, t, n, f); 远平面需设置得稍微大一点，避免光源的视锥范围无法覆盖全部场景"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-14T00:00:00+00:00"><meta property="article:modified_time" content="2025-04-14T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="
不要忘记改图床上传地址！
Assignment系列：Assignments/Assignment 4.GAMES202HW1/









  Assignment 2. A Review of Realistic Water Waveform Simulation



🚩 0x00 To begin with
这篇文章将会包含以下内容：

 GAMES202 作业 1
 不包含作业框架分析

For reference👇：

📺 B 站视频：








  GAMES202-高质量实时渲染


📦 代码仓库：








  congyuxiaoyoudao/GAMES202_Homework at working




master 分支上是 202 全部作业汇总，working 分支用于提交代码。需要原始作业可下载 master 分支的包

0x01 Shadow Map
完成两个任务点：

第一个 Pass 以光源作为相机渲染一张 ShadowMap，需要为 Shader 传递正确的 uLightMVP 矩阵；
第二个 Pass 获取光源传递的统一变量 FBO （ShadowMap），需要比较当前 ShadingPoint 的深度值与 ShadowMap 上记录的深度值，得出可见性项与 Shading 结果相乘。

DirectionalLight.js 中，完善 CalcLightMVP 函数：

 1		// Model transform
 2        mat4.translate(modelMatrix, modelMatrix, translate);
 3        mat4.scale(modelMatrix, modelMatrix, scale);
 4
 5        // View transform
 6        mat4.lookAt(viewMatrix, this.lightPos, this.focalPoint, this.lightUp);
 7
 8        // Projection transform
 9        var r = 100;
10        var l = -r;
11        var t = 100;
12        var b = -t;
13        var n = 0.01;
14        // caution! Depth of far plane should be a bit more larger
15        var f = 400;
16        
17        mat4.ortho(projectionMatrix, l, r, b, t, n, f);

远平面需设置得稍微大一点，避免光源的视锥范围无法覆盖全部场景"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://congyuxiaoyoudao.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Assignments","item":"https://congyuxiaoyoudao.github.io/posts/assignments/"},{"@type":"ListItem","position":3,"name":"","item":"https://congyuxiaoyoudao.github.io/posts/assignments/assignment-4.-games202-homework-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":" 不要忘记改图床上传地址！ Assignment系列：Assignments/Assignment 4.GAMES202HW1/ Assignment 2. A Review of Realistic Water Waveform Simulation 🚩 0x00 To begin with 这篇文章将会包含以下内容：\nGAMES202 作业 1 不包含作业框架分析 For reference👇：\n📺 B 站视频： GAMES202-高质量实时渲染 📦 代码仓库： congyuxiaoyoudao/GAMES202_Homework at working master 分支上是 202 全部作业汇总，working 分支用于提交代码。需要原始作业可下载 master 分支的包\n0x01 Shadow Map 完成两个任务点：\n第一个 Pass 以光源作为相机渲染一张 ShadowMap，需要为 Shader 传递正确的 uLightMVP 矩阵； 第二个 Pass 获取光源传递的统一变量 FBO （ShadowMap），需要比较当前 ShadingPoint 的深度值与 ShadowMap 上记录的深度值，得出可见性项与 Shading 结果相乘。 DirectionalLight.js 中，完善 CalcLightMVP 函数：\n1\t// Model transform 2 mat4.translate(modelMatrix, modelMatrix, translate); 3 mat4.scale(modelMatrix, modelMatrix, scale); 4 5 // View transform 6 mat4.lookAt(viewMatrix, this.lightPos, this.focalPoint, this.lightUp); 7 8 // Projection transform 9 var r = 100; 10 var l = -r; 11 var t = 100; 12 var b = -t; 13 var n = 0.01; 14 // caution! Depth of far plane should be a bit more larger 15 var f = 400; 16 17 mat4.ortho(projectionMatrix, l, r, b, t, n, f); 远平面需设置得稍微大一点，避免光源的视锥范围无法覆盖全部场景\n","keywords":[],"articleBody":" 不要忘记改图床上传地址！ Assignment系列：Assignments/Assignment 4.GAMES202HW1/ Assignment 2. A Review of Realistic Water Waveform Simulation 🚩 0x00 To begin with 这篇文章将会包含以下内容：\nGAMES202 作业 1 不包含作业框架分析 For reference👇：\n📺 B 站视频： GAMES202-高质量实时渲染 📦 代码仓库： congyuxiaoyoudao/GAMES202_Homework at working master 分支上是 202 全部作业汇总，working 分支用于提交代码。需要原始作业可下载 master 分支的包\n0x01 Shadow Map 完成两个任务点：\n第一个 Pass 以光源作为相机渲染一张 ShadowMap，需要为 Shader 传递正确的 uLightMVP 矩阵； 第二个 Pass 获取光源传递的统一变量 FBO （ShadowMap），需要比较当前 ShadingPoint 的深度值与 ShadowMap 上记录的深度值，得出可见性项与 Shading 结果相乘。 DirectionalLight.js 中，完善 CalcLightMVP 函数：\n1\t// Model transform 2 mat4.translate(modelMatrix, modelMatrix, translate); 3 mat4.scale(modelMatrix, modelMatrix, scale); 4 5 // View transform 6 mat4.lookAt(viewMatrix, this.lightPos, this.focalPoint, this.lightUp); 7 8 // Projection transform 9 var r = 100; 10 var l = -r; 11 var t = 100; 12 var b = -t; 13 var n = 0.01; 14 // caution! Depth of far plane should be a bit more larger 15 var f = 400; 16 17 mat4.ortho(projectionMatrix, l, r, b, t, n, f); 远平面需设置得稍微大一点，避免光源的视锥范围无法覆盖全部场景\nphongFragment.glsl 中，由于 ShadowMap 记录的深度值范围是 0-1，所以在比较之前需要把当前 ShadingPoint 到光源的距离转换到该区间，可以透视除法后转换至 NDC 后再映射至该范围：\n1 vec3 shadowCoord = vPositionFromLight.xyz / vPositionFromLight.w; // NDC 2 shadowCoord.xyz = (shadowCoord.xyz + 1.0) / 2.0; // -1~1 -\u003e 0-1 然后使用这个坐标传入 useShadowMap 函数进行比较：\n1float useShadowMap(sampler2D shadowMap, vec4 shadowCoord){ 2 float shadowMapDepth = unpack(texture2D(shadowMap, shadowCoord.xy)); 3 float visibility = shadowCoord.z \u003e (shadowMapDepth + EPS) ? 0.0 : 1.0; 4 return visibility; 5} 这里的 EPS（Epsilon）是框架定义的 Bias，作为阈值判断是否显著得大于记录的深度，用于修正自遮挡问题\n然后在 main 函数中调用 useShadowMap 和 phongColor 相乘即可。\n0x02 PCF 简单说下 PCF 的原理：针对当前 ShadingPoint，不仅考察其对应像素在 ShadowMap 上记录的深度，还要考察该像素周围（邻居像素）的深度，并逐一比较得出当前 ShadingPoint 在这些像素上的遮挡关系，然后将这些值求平均，得出一个平均的遮挡关系（介于 0-1 之间）。要点：\n并非对 ShadowMap 进行滤波 更像是对深度比较的结果进行滤波 框架推荐在圆盘状滤波核中随机采样，可以生成更加自然的模糊阴影，要完成的任务如下：\n调用任一随机采样函数，填充采样偏移数组（poissonDisk[NUM_SAMPLES]）; 考察每个偏移后像素记录的深度并与当前 ShadingsPoint 的深度进行比较，累加可见性项； 返回平均的可见性项。 这里使用 poissonDiskSamples 生成随机偏移：\n这段代码将会填充采样偏移数组，值形如：\n$$ \\begin{aligned} possionDisk_{i}=\u0026(\\cos\\theta,\\sin \\theta)\\cdot R \\\\ a_{0}\\leq \\theta\\leq a_{0}\u0026+2\\pi \\cdot rings \\\\ \\frac{1}{samples}^{3/4}\u0026\\leq R\\leq 1 \\end{aligned} $$ 在填充数组后，循环采样每一个偏移后的像素，比较深度，累加可见性项，最后求其均值：\n1// filter size is filter window size in pixels defined by FILTER_RADIUS / resolution 2float PCF(sampler2D shadowMap, vec4 coords, float filterSize) { 3 4 // STEP 1: uniform disk sampling generate a group of random sample points 5 poissonDiskSamples(coords.xy); 6 // Step 2: sample each point and accumulate each visibility component 7 float sum = 0.0; 8 for (int i = 0; i \u003c PCF_NUM_SAMPLES; i++) { 9 vec2 sampleOffset = poissonDisk[i] * filterSize; 10 vec2 uv = coords.xy + sampleOffset; 11 float shadowMapDepth = unpack(texture2D(shadowMap, uv)); 12 float visibility = coords.z \u003e (shadowMapDepth + EPS) ? 0.0 : 1.0; 13 sum += visibility; 14 } 15 // Step 3: return averaged visibility 16 return sum / float(PCF_NUM_SAMPLES); 17} 由于采样的偏移在 UV 空间中进行，所以需要除以贴图分辨率，框架给的是 2048，此外，乘一个 FILTER_RADIUS 调整偏移范围大小，该值越大，阴影越软\n同样在 main 函数中调用 PCF 和 phongColor 相乘即可。\n0x03 PCSS 观察现实的阴影，会发现在靠近投射阴影的障碍物时，阴影会更加硬，反之更软。PCSS 在 PCF 的基础上需要根据遮挡物的距离改变滤波核的大小，以调节阴影软硬，要完成的任务如下：\n获得遮挡物的平均深度，完善 findBlocker 函数； 根据相似三角形原理计算半影大小（penumbra size）； 根据半影大小调整滤波核大小，调用 PCF。 课程视频给出了一种确定可能遮挡当前 ShadingPoint 的范围，即连接 ShadingPoint 到 Light，在近平面处所截的区域。\n也是相似三角形，给定光源宽度即可计算：\n$$ blockerSearchRadius=W_{light} \\cdot \\frac{d_{PosToLight}-d_{near}}{d_{PosToLight}} $$ 然后将这个范围乘上偏移，在最终的偏移范围内随机采样，仅记录并累加为遮挡物的像素深度，最后求得平均遮挡物深度。\n1float findBlocker( sampler2D shadowMap, vec2 uv, float zReceiver ) { 2 float avgBlockerDepth = 0.0; 3 float blockerSum = 0.0; 4 poissonDiskSamples(uv); 5 6 // use proj on near plane to define search radius 7 float blockerSearchRadius = LIGHT_WIDTH_UV * (vPositionFromLight.z - NEAR_PLANE) / vPositionFromLight.z ; 8 9 for (int i = 0; i \u003c BLOCKER_SEARCH_NUM_SAMPLES; i++) { 10 vec2 sampleOffset = poissonDisk[i] * blockerSearchRadius; 11 vec2 uvSample = uv + sampleOffset; 12 float shadowMapDepth = unpack(texture2D(shadowMap, uvSample)); 13 if (shadowMapDepth \u003c zReceiver) { 14 avgBlockerDepth += shadowMapDepth; 15 blockerSum ++; 16 } 17 } 18 19 if(blockerSum == 0.0) return 1.0; // no blocker give a max depth value 20 else return avgBlockerDepth / blockerSum; 21} 之后在 PCSS 中调用之，再一次使用相似三角形获得半影大小，将其作为滤波器大小传入 PCF。\n1float PCSS(sampler2D shadowMap, vec4 coords){ 2 3 // STEP 1: avgblocker depth 4 float avgBlockerDepth = findBlocker(shadowMap, coords.xy, coords.z); 5 // STEP 2: penumbra size 6 // LIGHT_WIDTH_UV is defined by (LIGHT_WIDTH / resolution) 7 float penumbraSize = (coords.z - avgBlockerDepth) * LIGHT_WIDTH_UV / avgBlockerDepth; 8 // STEP 3: use penumbra size to define filter size 9 float visibility = PCF(shadowMap, coords, penumbraSize); 10 return visibility; 11 12} 这里相似三角形求解时直接使用屏幕空间灯宽度，可以直接将得到的半影直径作为滤波器大小传入 PCF，注意统一的量纲\n同样在 main 函数中调用 PCSS 和 phongColor 相乘即可。\n0x04 Bonus 多光源 要实现多光源，就需要为每个光源绘制一张 ShadowMap，常规的思路是为每张 ShadowMap 绑定一个 uniform，然后 Shader 里一一比较，合成最终的阴影。但是这样还需要向 Shader 传不同的光源的 ulightMVP 矩阵，随着光源数量增加，变量会异常地多，不是很优雅。\n这种思路要干的事：\n为每个光源渲染其独立的 ShadowMap 将每个光源的 ShadowMap 绑到 Material 的 uniform 中 将每个光源的 uLightPos 和 ulightMVP 传递给 Shader 在 Shader 中遍历每张 ShadowMap，累加可见性项 本来是想用这个思路的，但是框架要动的东西太多了，遂放弃\nGPUGems 中使用一张 ShadowMap 纹理：\nChapter 10. Parallel-Split Shadow Maps on Programmable GPUs …we reuse a single shadow-map texture in each rendering pass\n生成 ShadowMap 后马上合成阴影，之后的光源就可以复用这个 Texture，然后只需将每个光源的贡献累加即可。\n采用花桑氏的做法，每个光源都走一次 Camera Pass，然后混合。\n因为一个 material 只能存一张 ShadowMap，所以一个材质要为每个光源都 build 一遍，也是花桑氏的做法，用一个索引区分 material 对应的光源，先从父类 Material 改起，Material.js 中：\n然后是 PhongMaterial.js 中，在构造函数和 build 函数中增加灯光索引：\nShadowMaterial.js 中，同样：\nloadOBJ.js 中，为每个光源 build 一个材质：\nengine.js 中，为了方便一点封装一个加方向光的函数：\n1function AddDirectionalLight(renderer, intensity, color, position, focalPoint, up, hasShadowMap) { 2 const directionLight = new DirectionalLight(intensity, color, position, focalPoint, up, hasShadowMap, renderer.gl); 3 renderer.addLight(directionLight); 4} 然后改一下位置和颜色，再次增加两盏方向光：\n1AddDirectionalLight(renderer, 5000, [1, 0, 1], lightPos, focalPoint, lightUp, true); 2lightPos = [0, 80, -80]; 3AddDirectionalLight(renderer, 500, [0, 1, 1], lightPos, focalPoint, lightUp, true); 4lightPos = [80, 80, 0]; 5AddDirectionalLight(renderer, 500, [1, 1, 0], lightPos, focalPoint, lightUp, true); 最后 WebGLRenderer中.js 中，只为对应光源索引的 material 进行绘制，然后把其余光源的绘制结果叠到第一个光源的绘制结果（FrameBuffer）上：\n这里按我原来写的把 mesh 的旋转放 Camera Pass 里了，所以加了多光源会出现很严重的抖动，拿到外面即可\n最后再让光源转起来：\n1let lightPos = this.lights[l].entity.lightPos; 2lightPos = vec3.rotateY(lightPos, lightPos, this.lights[l].entity.focalPoint, degreeToRadian(10) * deltaTime); 3this.lights[l].entity.lightPos = lightPos; 大功告成，看一下三体运动：\n动态物体 目前可以看到物体和光源是不支持旋转的，这里加上。不动脑子一点的办法是全局搜索 Transform，然后一个一个加上旋转就行，这里笔者尽量给出有逻辑的修改方式。\n框架中的渲染循环位于 engine.js，最后有个 setTransform 函数，在这里加上旋转变换：\n1function setTransform(t_x, t_y, t_z, r_x, r_y, r_z, s_x, s_y, s_z) { 2\treturn { 3\tmodelTransX: t_x, 4\tmodelTransY: t_y, 5\tmodelTransZ: t_z, 6\t// Begin TOP changes 7\tmodelRotateX: r_x, 8\tmodelRotateY: r_y, 9\tmodelRotateZ: r_z, 10\t// End TOP changes 11\tmodelScaleX: s_x, 12\tmodelScaleY: s_y, 13\tmodelScaleZ: s_z, 14\t}; 15} 然后在上面部分代码设置模型变换中加上旋转的参数，目前先给 0：\n1let floorTransform = setTransform(0, 0, -30, 0, 0, 0, 4, 4, 4); 2let obj1Transform = setTransform(0, 0, 0, 0, 0, 0, 20, 20, 20); 3let obj2Transform = setTransform(40, 0, -40, 0, 0, 0, 10, 10, 10); 这个变换作为 loadOBJ 函数的参数用于设置模型变换，先看看这个函数干了什么（loadOBJ.js）：\n涉及到 transform 的地方就这些，一个是 Mesh 的 Ctor，另一个是 material 的 build 函数。\n在 Mesh.js 中，更改其构造函数，增加对旋转的支持：\n1// TRSTransform Ctor 2 constructor(translate = [0, 0, 0], rotate = [0, 0, 0], scale = [1, 1, 1]) { 3 this.translate = translate; 4\tthis.rotate = rotate; 5 this.scale = scale; 6 } 7 8// ... 9 10// Mesh Ctor 11\tconst modelTranslation = [transform.modelTransX, transform.modelTransY, transform.modelTransZ]; 12\tconst modelRotation = [transform.modelRotateX, transform.modelRotateY, transform.modelRotateZ]; 13\tconst modelScale = [transform.modelScaleX, transform.modelScaleY, transform.modelScaleZ]; 14\tlet meshTrans = new TRSTransform(modelTranslation, modelRotation, modelScale); 回到 loadOBJ.js，从传入的 transform 中解析模型旋转，然后传入 material 的 build 函数：\n1// object.traverse 2let Translation = [transform.modelTransX, transform.modelTransY, transform.modelTransZ]; 3let Rotation = [transform.modelRotateX, transform.modelRotateY, transform.modelRotateZ]; 4let Scale = [transform.modelScaleX, transform.modelScaleY, transform.modelScaleZ]; 5 6material = buildPhongMaterial(colorMap, mat.specular.toArray(), light, Translation, Rotation, Scale, \"./src/shaders/phongShader/phongVertex.glsl\", \"./src/shaders/phongShader/phongFragment.glsl\"); 7shadowMaterial = buildShadowMaterial(light, Translation, Rotation, Scale, \"./src/shaders/shadowShader/shadowVertex.glsl\", \"./src/shaders/shadowShader/shadowFragment.glsl\"); 然后自然需要对 material 的变换进行支持，依次在 PhongMaterial.js 和 ShadowMaterial.js 中为上述创建材质的函数添加对旋转的支持：\nPhongMaterial.js 中：\n1// PhongMaterial Ctor 2 constructor(color, specular, light, translate, rotate, scale, vertexShader, fragmentShader) { 3 let lightMVP = light.CalcLightMVP(translate, rotate, scale); 4 5// material builder function 6async function buildPhongMaterial(color, specular, light, translate, rotate, scale, vertexPath, fragmentPath) { 7 8 let vertexShader = await getShaderString(vertexPath); 9 let fragmentShader = await getShaderString(fragmentPath); 10 return new PhongMaterial(color, specular, light, translate, rotate, scale, vertexShader, fragmentShader); 11} 同样，ShadowMaterial.js 中：\n1class ShadowMaterial extends Material { 2 constructor(light, translate, rotate, scale, vertexShader, fragmentShader) { 3 let lightMVP = light.CalcLightMVP(translate, rotate, scale); 4 super({ 5 'uLightMVP': { type: 'matrix4fv', value: lightMVP } 6 }, [], vertexShader, fragmentShader, light.fbo); 7 } 8} 9 10async function buildShadowMaterial(light, translate, rotate, scale, vertexPath, fragmentPath) { 11 let vertexShader = await getShaderString(vertexPath); 12 let fragmentShader = await getShaderString(fragmentPath); 13 return new ShadowMaterial(light, translate,rotate, scale, vertexShader, fragmentShader); 14} 注意到，上面传递的 lightMVP 矩阵是通过 CalcLightMVP 计算的，所以下一步为其增加对旋转的支持，DirectionalLight.js 中：\n1 CalcLightMVP(translate, rotate, scale) { 2 let lightMVP = mat4.create(); 3 let modelMatrix = mat4.create(); 4 let viewMatrix = mat4.create(); 5 let projectionMatrix = mat4.create(); 6 7 // Model transform 8 mat4.translate(modelMatrix, modelMatrix, translate); 9 mat4.rotateX(modelMatrix, modelMatrix, rotate[0]); 10 mat4.rotateY(modelMatrix, modelMatrix, rotate[1]); 11 mat4.rotateZ(modelMatrix, modelMatrix, rotate[2]); 12 mat4.scale(modelMatrix, modelMatrix, scale); 记得把上面灯的 Mesh（cube）模型变换的旋转参数加上\n1// DirectionalLight Ctor 2this.mesh = Mesh.cube(setTransform(0, 0, 0, 0, 0, 0, 0.2, 0.2, 0.2, 0)); 最后，渲染循环每一帧绘制时会调用 WebGLRenderer 的 render 函数，后者又会为每一个实体调用其 meshRender 的 draw 函数，该函数需要调用 bindCameraParameters，这里向 Shader 传递了作为 uniform 的模型变换矩阵，在这里加上旋转（MeshRender.js 中）：\n1mat4.rotateX(modelMatrix, modelMatrix, this.mesh.transform.rotate[0]); 2mat4.rotateY(modelMatrix, modelMatrix, this.mesh.transform.rotate[1]); 3mat4.rotateZ(modelMatrix, modelMatrix, this.mesh.transform.rotate[2]); 对旋转的支持到这里就差不多了，现在我们需要让模型随着时间按 Y 轴旋转，我们可以从循环里拿到当前时间，然后与保存的时间相减得到差值，向 render 函数传入这个差值然后每帧累加一个旋转角度即可。\n最后，在 WebGLRenderer.js，render 函数中每帧需要更新光源对应的 FBO（帧缓冲区），否则 ShadowMap 的内容会每帧叠加，以及更新传入 Shader 的 uniform 变量。\n这里 updateMVP 是我自定义的一个函数：\n1 updateMVP(mesh, lightEntity){ 2 let translate = mesh.transform.translate; 3 let rotate = mesh.transform.rotate; 4 let scale = mesh.transform.scale; 5 let MVP = lightEntity.CalcLightMVP(translate, rotate, scale); 6 return MVP; 7 } 完成之后就可以转圈圈~\n","wordCount":"1316","inLanguage":"zh","datePublished":"2025-04-14T00:00:00Z","dateModified":"2025-04-14T00:00:00Z","author":{"@type":"Person","name":"The Only Problem"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://congyuxiaoyoudao.github.io/posts/assignments/assignment-4.-games202-homework-1/"},"publisher":{"@type":"Organization","name":"The Only Problem's Blog","logo":{"@type":"ImageObject","url":"https://congyuxiaoyoudao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://congyuxiaoyoudao.github.io/ accesskey=h title="The Only Problem's Blog (Alt + H)">The Only Problem's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://congyuxiaoyoudao.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://congyuxiaoyoudao.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://congyuxiaoyoudao.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://congyuxiaoyoudao.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://congyuxiaoyoudao.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://congyuxiaoyoudao.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://congyuxiaoyoudao.github.io/posts/assignments/>Assignments</a></div><h1 class="post-title entry-hint-parent"></h1><div class=post-meta><span title='2025-04-14 00:00:00 +0000 UTC'>四月 14, 2025</span>&nbsp;·&nbsp;7 分钟&nbsp;·&nbsp;The Only Problem</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#-0x00-to-begin-with aria-label="🚩 0x00 To begin with">🚩 0x00 To begin with</a></li><li><a href=#0x01-shadow-map aria-label="0x01 Shadow Map">0x01 Shadow Map</a></li><li><a href=#0x02-pcf aria-label="0x02 PCF">0x02 PCF</a></li><li><a href=#0x03-pcss aria-label="0x03 PCSS">0x03 PCSS</a></li><li><a href=#0x04-bonus aria-label="0x04 Bonus">0x04 Bonus</a><ul><li><a href=#%e5%a4%9a%e5%85%89%e6%ba%90 aria-label=多光源>多光源</a></li><li><a href=#%e5%8a%a8%e6%80%81%e7%89%a9%e4%bd%93 aria-label=动态物体>动态物体</a></li></ul></li></ul></div></details></div><div class=post-content><blockquote><p>不要忘记改图床上传地址！
Assignment系列：Assignments/Assignment 4.GAMES202HW1/
<a href=./Assignment%202.%20A%20Review%20of%20Realistic%20Water%20Waveform%20Simulation.md>Assignment 2. A Review of Realistic Water Waveform Simulation</a></p></blockquote><hr><h2 id=-0x00-to-begin-with>🚩 0x00 To begin with<a hidden class=anchor aria-hidden=true href=#-0x00-to-begin-with>#</a></h2><p>这篇文章将会包含以下内容：</p><ul><li><input checked disabled type=checkbox> GAMES202 作业 1</li><li><input checked disabled type=checkbox> <strong>不</strong>包含作业框架分析</li></ul><p><strong>For reference</strong>👇：</p><ul><li>📺 B 站视频：
<a href="https://www.bilibili.com/video/BV1YK4y1T7yY/?spm_id_from=333.337.top_right_bar_window_custom_collection.content.click&amp;vd_source=b6584cebba3a7a1a34d2f60d63bdc868">GAMES202-高质量实时渲染</a></li><li>📦 代码仓库：
<a href=https://github.com/congyuxiaoyoudao/GAMES202_Homework/tree/working>congyuxiaoyoudao/GAMES202_Homework at working</a></li></ul><blockquote><p>master 分支上是 202 全部作业汇总，working 分支用于提交代码。需要原始作业可下载 master 分支的包</p></blockquote><hr><h2 id=0x01-shadow-map>0x01 Shadow Map<a hidden class=anchor aria-hidden=true href=#0x01-shadow-map>#</a></h2><p>完成两个任务点：</p><ol><li>第一个 Pass 以光源作为相机渲染一张 ShadowMap，需要为 Shader 传递正确的 <code>uLightMVP</code> 矩阵；</li><li>第二个 Pass 获取光源传递的统一变量 FBO （ShadowMap），需要比较当前 ShadingPoint 的深度值与 ShadowMap 上记录的深度值，得出可见性项与 Shading 结果相乘。</li></ol><p>DirectionalLight.js 中，完善 <code>CalcLightMVP</code> 函数：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504151505787.png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-glsl data-lang=glsl><span class=line><span class=ln> 1</span><span class=cl>		<span class=c1>// Model transform</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>        <span class=n>mat4</span><span class=p>.</span><span class=n>translate</span><span class=p>(</span><span class=n>modelMatrix</span><span class=p>,</span> <span class=n>modelMatrix</span><span class=p>,</span> <span class=n>translate</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>        <span class=n>mat4</span><span class=p>.</span><span class=n>scale</span><span class=p>(</span><span class=n>modelMatrix</span><span class=p>,</span> <span class=n>modelMatrix</span><span class=p>,</span> <span class=n>scale</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>
</span></span><span class=line><span class=ln> 5</span><span class=cl>        <span class=c1>// View transform</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>        <span class=n>mat4</span><span class=p>.</span><span class=n>lookAt</span><span class=p>(</span><span class=n>viewMatrix</span><span class=p>,</span> <span class=k>this</span><span class=p>.</span><span class=n>lightPos</span><span class=p>,</span> <span class=k>this</span><span class=p>.</span><span class=n>focalPoint</span><span class=p>,</span> <span class=k>this</span><span class=p>.</span><span class=n>lightUp</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>
</span></span><span class=line><span class=ln> 8</span><span class=cl>        <span class=c1>// Projection transform</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>        <span class=n>var</span> <span class=n>r</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>        <span class=n>var</span> <span class=n>l</span> <span class=o>=</span> <span class=o>-</span><span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>        <span class=n>var</span> <span class=n>t</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>        <span class=n>var</span> <span class=n>b</span> <span class=o>=</span> <span class=o>-</span><span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>        <span class=n>var</span> <span class=n>n</span> <span class=o>=</span> <span class=mf>0.01</span><span class=p>;</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>        <span class=c1>// caution! Depth of far plane should be a bit more larger</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>        <span class=n>var</span> <span class=n>f</span> <span class=o>=</span> <span class=mi>400</span><span class=p>;</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>        
</span></span><span class=line><span class=ln>17</span><span class=cl>        <span class=n>mat4</span><span class=p>.</span><span class=n>ortho</span><span class=p>(</span><span class=n>projectionMatrix</span><span class=p>,</span> <span class=n>l</span><span class=p>,</span> <span class=n>r</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>t</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>f</span><span class=p>);</span>
</span></span></code></pre></div><blockquote><p>远平面需设置得稍微大一点，避免光源的视锥范围无法覆盖全部场景</p></blockquote><p>phongFragment.glsl 中，由于 ShadowMap 记录的深度值范围是 0-1，所以在比较之前需要把当前 ShadingPoint 到光源的距离转换到该区间，可以透视除法后转换至 NDC 后再映射至该范围：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-glsl data-lang=glsl><span class=line><span class=ln>1</span><span class=cl>  <span class=k>vec3</span> <span class=n>shadowCoord</span> <span class=o>=</span> <span class=n>vPositionFromLight</span><span class=p>.</span><span class=n>xyz</span> <span class=o>/</span> <span class=n>vPositionFromLight</span><span class=p>.</span><span class=n>w</span><span class=p>;</span> <span class=c1>// NDC</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>  <span class=n>shadowCoord</span><span class=p>.</span><span class=n>xyz</span> <span class=o>=</span> <span class=p>(</span><span class=n>shadowCoord</span><span class=p>.</span><span class=n>xyz</span> <span class=o>+</span> <span class=mf>1.0</span><span class=p>)</span> <span class=o>/</span> <span class=mf>2.0</span><span class=p>;</span> <span class=c1>// -1~1 -&gt; 0-1</span>
</span></span></code></pre></div><p>然后使用这个坐标传入 <code>useShadowMap</code> 函数进行比较：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504151515031.png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-glsl data-lang=glsl><span class=line><span class=ln>1</span><span class=cl><span class=k>float</span> <span class=n>useShadowMap</span><span class=p>(</span><span class=k>sampler2D</span> <span class=n>shadowMap</span><span class=p>,</span> <span class=k>vec4</span> <span class=n>shadowCoord</span><span class=p>){</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>  <span class=k>float</span> <span class=n>shadowMapDepth</span> <span class=o>=</span> <span class=n>unpack</span><span class=p>(</span><span class=n>texture2D</span><span class=p>(</span><span class=n>shadowMap</span><span class=p>,</span> <span class=n>shadowCoord</span><span class=p>.</span><span class=n>xy</span><span class=p>));</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>  <span class=k>float</span> <span class=n>visibility</span> <span class=o>=</span> <span class=n>shadowCoord</span><span class=p>.</span><span class=n>z</span> <span class=o>&gt;</span> <span class=p>(</span><span class=n>shadowMapDepth</span> <span class=o>+</span> <span class=n>EPS</span><span class=p>)</span> <span class=o>?</span> <span class=mf>0.0</span> <span class=o>:</span> <span class=mf>1.0</span><span class=p>;</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>  <span class=k>return</span> <span class=n>visibility</span><span class=p>;</span>
</span></span><span class=line><span class=ln>5</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p>这里的 EPS（Epsilon）是框架定义的 Bias，作为阈值判断是否显著得大于记录的深度，用于修正自遮挡问题</p></blockquote><p>然后在 <code>main</code> 函数中调用 <code>useShadowMap</code> 和 <code>phongColor</code> 相乘即可。</p><p><img alt="ShadowMap 硬阴影" loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504151522650.png></p><hr><h2 id=0x02-pcf>0x02 PCF<a hidden class=anchor aria-hidden=true href=#0x02-pcf>#</a></h2><p>简单说下 PCF 的原理：针对当前 ShadingPoint，不仅考察其对应像素在 ShadowMap 上记录的深度，还要考察该像素周围（邻居像素）的深度，并逐一比较得出当前 ShadingPoint 在这些像素上的遮挡关系，然后将这些值求平均，得出一个平均的遮挡关系（介于 0-1 之间）。要点：</p><ul><li>并非对 ShadowMap 进行滤波</li><li>更像是对深度比较的结果进行滤波</li></ul><p>框架推荐在圆盘状滤波核中随机采样，可以生成更加自然的模糊阴影，要完成的任务如下：</p><ol><li>调用任一随机采样函数，填充采样偏移数组（<code>poissonDisk[NUM_SAMPLES]</code>）;</li><li>考察每个偏移后像素记录的深度并与当前 ShadingsPoint 的深度进行比较，累加可见性项；</li><li>返回平均的可见性项。</li></ol><p>这里使用 <code>poissonDiskSamples</code> 生成随机偏移：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504151557964.png></p><p>这段代码将会填充采样偏移数组，值形如：</p><div>$$
\begin{aligned}
possionDisk_{i}=&(\cos\theta,\sin \theta)\cdot R \\
a_{0}\leq \theta\leq a_{0}&+2\pi \cdot rings \\
\frac{1}{samples}^{3/4}&\leq R\leq 1
\end{aligned}
$$</div><p>在填充数组后，循环采样每一个偏移后的像素，比较深度，累加可见性项，最后求其均值：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504151618280.png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-glsl data-lang=glsl><span class=line><span class=ln> 1</span><span class=cl><span class=c1>// filter size is filter window size in pixels defined by FILTER_RADIUS / resolution</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl><span class=k>float</span> <span class=n>PCF</span><span class=p>(</span><span class=k>sampler2D</span> <span class=n>shadowMap</span><span class=p>,</span> <span class=k>vec4</span> <span class=n>coords</span><span class=p>,</span> <span class=k>float</span> <span class=n>filterSize</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>
</span></span><span class=line><span class=ln> 4</span><span class=cl>  <span class=c1>// STEP 1: uniform disk sampling generate a group of random sample points</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>  <span class=n>poissonDiskSamples</span><span class=p>(</span><span class=n>coords</span><span class=p>.</span><span class=n>xy</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>  <span class=c1>// Step 2: sample each point and accumulate each visibility component</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>  <span class=k>float</span> <span class=n>sum</span> <span class=o>=</span> <span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=k>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mo>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>PCF_NUM_SAMPLES</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>    <span class=k>vec2</span> <span class=n>sampleOffset</span> <span class=o>=</span> <span class=n>poissonDisk</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>*</span> <span class=n>filterSize</span><span class=p>;</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>    <span class=k>vec2</span> <span class=n>uv</span> <span class=o>=</span> <span class=n>coords</span><span class=p>.</span><span class=n>xy</span> <span class=o>+</span> <span class=n>sampleOffset</span><span class=p>;</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>    <span class=k>float</span> <span class=n>shadowMapDepth</span> <span class=o>=</span> <span class=n>unpack</span><span class=p>(</span><span class=n>texture2D</span><span class=p>(</span><span class=n>shadowMap</span><span class=p>,</span> <span class=n>uv</span><span class=p>));</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>    <span class=k>float</span> <span class=n>visibility</span> <span class=o>=</span> <span class=n>coords</span><span class=p>.</span><span class=n>z</span> <span class=o>&gt;</span> <span class=p>(</span><span class=n>shadowMapDepth</span> <span class=o>+</span> <span class=n>EPS</span><span class=p>)</span> <span class=o>?</span> <span class=mf>0.0</span> <span class=o>:</span> <span class=mf>1.0</span><span class=p>;</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>    <span class=n>sum</span> <span class=o>+=</span> <span class=n>visibility</span><span class=p>;</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>  <span class=c1>// Step 3: return averaged visibility</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>  <span class=k>return</span> <span class=n>sum</span> <span class=o>/</span> <span class=k>float</span><span class=p>(</span><span class=n>PCF_NUM_SAMPLES</span><span class=p>);</span>
</span></span><span class=line><span class=ln>17</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p>由于采样的偏移在 UV 空间中进行，所以需要除以贴图分辨率，框架给的是 2048，此外，乘一个 <code>FILTER_RADIUS</code> 调整偏移范围大小，该值越大，阴影越软</p></blockquote><p>同样在 <code>main</code> 函数中调用 <code>PCF</code> 和 <code>phongColor</code> 相乘即可。</p><p><img alt=阴影软软的 loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504151624409.png></p><hr><h2 id=0x03-pcss>0x03 PCSS<a hidden class=anchor aria-hidden=true href=#0x03-pcss>#</a></h2><p>观察现实的阴影，会发现在靠近投射阴影的障碍物时，阴影会更加硬，反之更软。PCSS 在 PCF 的基础上需要根据遮挡物的距离改变滤波核的大小，以调节阴影软硬，要完成的任务如下：</p><ol><li>获得遮挡物的平均深度，完善 <code>findBlocker</code> 函数；</li><li>根据相似三角形原理计算半影大小（penumbra size）；</li><li>根据半影大小调整滤波核大小，调用 PCF。</li></ol><p>课程视频给出了一种确定可能遮挡当前 ShadingPoint 的范围，即连接 ShadingPoint 到 Light，在近平面处所截的区域。</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504151640949.png></p><p>也是相似三角形，给定光源宽度即可计算：</p><div>$$
blockerSearchRadius=W_{light} \cdot \frac{d_{PosToLight}-d_{near}}{d_{PosToLight}}
$$</div><p>然后将这个范围乘上偏移，在最终的偏移范围内随机采样，仅记录并累加为遮挡物的像素深度，最后求得平均遮挡物深度。</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504151634249.png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-glsl data-lang=glsl><span class=line><span class=ln> 1</span><span class=cl><span class=k>float</span> <span class=n>findBlocker</span><span class=p>(</span> <span class=k>sampler2D</span> <span class=n>shadowMap</span><span class=p>,</span>  <span class=k>vec2</span> <span class=n>uv</span><span class=p>,</span> <span class=k>float</span> <span class=n>zReceiver</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>  <span class=k>float</span> <span class=n>avgBlockerDepth</span> <span class=o>=</span> <span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>  <span class=k>float</span> <span class=n>blockerSum</span> <span class=o>=</span> <span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>  <span class=n>poissonDiskSamples</span><span class=p>(</span><span class=n>uv</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>
</span></span><span class=line><span class=ln> 6</span><span class=cl>  <span class=c1>// use proj on near plane to define search radius</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>  <span class=k>float</span> <span class=n>blockerSearchRadius</span> <span class=o>=</span> <span class=n>LIGHT_WIDTH_UV</span> <span class=o>*</span> <span class=p>(</span><span class=n>vPositionFromLight</span><span class=p>.</span><span class=n>z</span> <span class=o>-</span> <span class=n>NEAR_PLANE</span><span class=p>)</span> <span class=o>/</span> <span class=n>vPositionFromLight</span><span class=p>.</span><span class=n>z</span> <span class=p>;</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>
</span></span><span class=line><span class=ln> 9</span><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=k>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mo>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>BLOCKER_SEARCH_NUM_SAMPLES</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>    <span class=k>vec2</span> <span class=n>sampleOffset</span> <span class=o>=</span> <span class=n>poissonDisk</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>*</span> <span class=n>blockerSearchRadius</span><span class=p>;</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>    <span class=k>vec2</span> <span class=n>uvSample</span> <span class=o>=</span> <span class=n>uv</span> <span class=o>+</span> <span class=n>sampleOffset</span><span class=p>;</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>    <span class=k>float</span> <span class=n>shadowMapDepth</span> <span class=o>=</span> <span class=n>unpack</span><span class=p>(</span><span class=n>texture2D</span><span class=p>(</span><span class=n>shadowMap</span><span class=p>,</span> <span class=n>uvSample</span><span class=p>));</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>shadowMapDepth</span> <span class=o>&lt;</span> <span class=n>zReceiver</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>      <span class=n>avgBlockerDepth</span> <span class=o>+=</span> <span class=n>shadowMapDepth</span><span class=p>;</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>      <span class=n>blockerSum</span> <span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>17</span><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>
</span></span><span class=line><span class=ln>19</span><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>blockerSum</span> <span class=o>==</span> <span class=mf>0.0</span><span class=p>)</span> <span class=k>return</span> <span class=mf>1.0</span><span class=p>;</span> <span class=c1>// no blocker give a max depth value</span>
</span></span><span class=line><span class=ln>20</span><span class=cl>  <span class=k>else</span> <span class=k>return</span> <span class=n>avgBlockerDepth</span> <span class=o>/</span> <span class=n>blockerSum</span><span class=p>;</span>
</span></span><span class=line><span class=ln>21</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>之后在 PCSS 中调用之，再一次使用相似三角形获得半影大小，将其作为滤波器大小传入 PCF。</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504151709181.png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-glsl data-lang=glsl><span class=line><span class=ln> 1</span><span class=cl><span class=k>float</span> <span class=n>PCSS</span><span class=p>(</span><span class=k>sampler2D</span> <span class=n>shadowMap</span><span class=p>,</span> <span class=k>vec4</span> <span class=n>coords</span><span class=p>){</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>
</span></span><span class=line><span class=ln> 3</span><span class=cl>  <span class=c1>// STEP 1: avgblocker depth</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>  <span class=k>float</span> <span class=n>avgBlockerDepth</span> <span class=o>=</span> <span class=n>findBlocker</span><span class=p>(</span><span class=n>shadowMap</span><span class=p>,</span> <span class=n>coords</span><span class=p>.</span><span class=n>xy</span><span class=p>,</span> <span class=n>coords</span><span class=p>.</span><span class=n>z</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>  <span class=c1>// STEP 2: penumbra size</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>  <span class=c1>// LIGHT_WIDTH_UV is defined by (LIGHT_WIDTH / resolution)</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>  <span class=k>float</span> <span class=n>penumbraSize</span> <span class=o>=</span> <span class=p>(</span><span class=n>coords</span><span class=p>.</span><span class=n>z</span> <span class=o>-</span> <span class=n>avgBlockerDepth</span><span class=p>)</span> <span class=o>*</span> <span class=n>LIGHT_WIDTH_UV</span> <span class=o>/</span> <span class=n>avgBlockerDepth</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>  <span class=c1>// STEP 3: use penumbra size to define filter size</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>  <span class=k>float</span> <span class=n>visibility</span> <span class=o>=</span> <span class=n>PCF</span><span class=p>(</span><span class=n>shadowMap</span><span class=p>,</span> <span class=n>coords</span><span class=p>,</span> <span class=n>penumbraSize</span><span class=p>);</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>  <span class=k>return</span> <span class=n>visibility</span><span class=p>;</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>
</span></span><span class=line><span class=ln>12</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p>这里相似三角形求解时直接使用屏幕空间灯宽度，可以直接将得到的半影直径作为滤波器大小传入 <code>PCF</code>，注意统一的量纲</p></blockquote><p>同样在 <code>main</code> 函数中调用 <code>PCSS</code> 和 <code>phongColor</code> 相乘即可。</p><p><img alt=靠近遮挡物的硬阴影和远离遮挡物的软阴影 loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504151713765.png></p><hr><h2 id=0x04-bonus>0x04 Bonus<a hidden class=anchor aria-hidden=true href=#0x04-bonus>#</a></h2><h3 id=多光源><strong>多光源</strong><a hidden class=anchor aria-hidden=true href=#多光源>#</a></h3><p>要实现多光源，就需要为每个光源绘制一张 ShadowMap，常规的思路是为每张 ShadowMap 绑定一个 <code>uniform</code>，然后 Shader 里一一比较，合成最终的阴影。但是这样还需要向 Shader 传不同的光源的 <code>ulightMVP</code> 矩阵，随着光源数量增加，变量会异常地多，不是很优雅。</p><p>这种思路要干的事：</p><ul><li>为每个光源渲染其独立的 ShadowMap</li><li>将每个光源的 ShadowMap 绑到 Material 的 <code>uniform</code> 中</li><li>将每个光源的 <code>uLightPos</code> 和 <code>ulightMVP</code> 传递给 Shader</li><li>在 Shader 中遍历每张 ShadowMap，累加可见性项</li></ul><blockquote><p>本来是想用这个思路的，但是框架要动的东西太多了，遂放弃</p></blockquote><p><em>GPUGems</em> 中使用一张 ShadowMap 纹理：</p><p><a href=https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-10-parallel-split-shadow-maps-programmable-gpus>Chapter 10. Parallel-Split Shadow Maps on Programmable GPUs</a></p><blockquote><p>&mldr;we reuse a single shadow-map texture in each rendering pass</p></blockquote><p>生成 ShadowMap 后马上合成阴影，之后的光源就可以复用这个 Texture，然后只需将每个光源的贡献累加即可。</p><p>采用花桑氏的做法，每个光源都走一次 Camera Pass，然后混合。</p><p>因为一个 material 只能存一张 ShadowMap，所以一个材质要为每个光源都 build 一遍，也是花桑氏的做法，用一个索引区分 material 对应的光源，先从父类 <code>Material</code> 改起，Material.js 中：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504162302185.png></p><p>然后是 PhongMaterial.js 中，在构造函数和 build 函数中增加灯光索引：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504162345660.png></p><p>ShadowMaterial.js 中，同样：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504162346969.png></p><p>loadOBJ.js 中，为每个光源 build 一个材质：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504162348770.png></p><p>engine.js 中，为了方便一点封装一个加方向光的函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=ln>1</span><span class=cl><span class=kd>function</span> <span class=nx>AddDirectionalLight</span><span class=p>(</span><span class=nx>renderer</span><span class=p>,</span> <span class=nx>intensity</span><span class=p>,</span> <span class=nx>color</span><span class=p>,</span> <span class=nx>position</span><span class=p>,</span> <span class=nx>focalPoint</span><span class=p>,</span> <span class=nx>up</span><span class=p>,</span> <span class=nx>hasShadowMap</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>    <span class=kr>const</span> <span class=nx>directionLight</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>DirectionalLight</span><span class=p>(</span><span class=nx>intensity</span><span class=p>,</span> <span class=nx>color</span><span class=p>,</span> <span class=nx>position</span><span class=p>,</span> <span class=nx>focalPoint</span><span class=p>,</span> <span class=nx>up</span><span class=p>,</span> <span class=nx>hasShadowMap</span><span class=p>,</span> <span class=nx>renderer</span><span class=p>.</span><span class=nx>gl</span><span class=p>);</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>    <span class=nx>renderer</span><span class=p>.</span><span class=nx>addLight</span><span class=p>(</span><span class=nx>directionLight</span><span class=p>);</span>
</span></span><span class=line><span class=ln>4</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>然后改一下位置和颜色，再次增加两盏方向光：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=ln>1</span><span class=cl><span class=nx>AddDirectionalLight</span><span class=p>(</span><span class=nx>renderer</span><span class=p>,</span> <span class=mi>5000</span><span class=p>,</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>],</span> <span class=nx>lightPos</span><span class=p>,</span> <span class=nx>focalPoint</span><span class=p>,</span> <span class=nx>lightUp</span><span class=p>,</span> <span class=kc>true</span><span class=p>);</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=nx>lightPos</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>80</span><span class=p>,</span> <span class=o>-</span><span class=mi>80</span><span class=p>];</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=nx>AddDirectionalLight</span><span class=p>(</span><span class=nx>renderer</span><span class=p>,</span> <span class=mi>500</span><span class=p>,</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>],</span> <span class=nx>lightPos</span><span class=p>,</span> <span class=nx>focalPoint</span><span class=p>,</span> <span class=nx>lightUp</span><span class=p>,</span> <span class=kc>true</span><span class=p>);</span>
</span></span><span class=line><span class=ln>4</span><span class=cl><span class=nx>lightPos</span> <span class=o>=</span> <span class=p>[</span><span class=mi>80</span><span class=p>,</span> <span class=mi>80</span><span class=p>,</span> <span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=ln>5</span><span class=cl><span class=nx>AddDirectionalLight</span><span class=p>(</span><span class=nx>renderer</span><span class=p>,</span> <span class=mi>500</span><span class=p>,</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>],</span> <span class=nx>lightPos</span><span class=p>,</span> <span class=nx>focalPoint</span><span class=p>,</span> <span class=nx>lightUp</span><span class=p>,</span> <span class=kc>true</span><span class=p>);</span>
</span></span></code></pre></div><p>最后 WebGLRenderer中.js 中，只为对应光源索引的 material 进行绘制，然后把其余光源的绘制结果叠到第一个光源的绘制结果（FrameBuffer）上：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504162354923.png></p><blockquote><p>这里按我原来写的把 mesh 的旋转放 Camera Pass 里了，所以加了多光源会出现很严重的抖动，拿到外面即可</p></blockquote><p>最后再让光源转起来：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504162357479.png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=ln>1</span><span class=cl><span class=kd>let</span> <span class=nx>lightPos</span> <span class=o>=</span> <span class=k>this</span><span class=p>.</span><span class=nx>lights</span><span class=p>[</span><span class=nx>l</span><span class=p>].</span><span class=nx>entity</span><span class=p>.</span><span class=nx>lightPos</span><span class=p>;</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=nx>lightPos</span> <span class=o>=</span> <span class=nx>vec3</span><span class=p>.</span><span class=nx>rotateY</span><span class=p>(</span><span class=nx>lightPos</span><span class=p>,</span> <span class=nx>lightPos</span><span class=p>,</span> <span class=k>this</span><span class=p>.</span><span class=nx>lights</span><span class=p>[</span><span class=nx>l</span><span class=p>].</span><span class=nx>entity</span><span class=p>.</span><span class=nx>focalPoint</span><span class=p>,</span> <span class=nx>degreeToRadian</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span> <span class=o>*</span> <span class=nx>deltaTime</span><span class=p>);</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=k>this</span><span class=p>.</span><span class=nx>lights</span><span class=p>[</span><span class=nx>l</span><span class=p>].</span><span class=nx>entity</span><span class=p>.</span><span class=nx>lightPos</span> <span class=o>=</span> <span class=nx>lightPos</span><span class=p>;</span>
</span></span></code></pre></div><p>大功告成，看一下三体运动：</p><p><img alt=“三体运动” loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504170002614.gif></p><h3 id=动态物体><strong>动态物体</strong><a hidden class=anchor aria-hidden=true href=#动态物体>#</a></h3><p>目前可以看到物体和光源是不支持旋转的，这里加上。不动脑子一点的办法是全局搜索 Transform，然后一个一个加上旋转就行，这里笔者尽量给出有逻辑的修改方式。</p><p>框架中的渲染循环位于 engine.js，最后有个 <code>setTransform</code> 函数，在这里加上旋转变换：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504151944573.png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=ln> 1</span><span class=cl><span class=kd>function</span> <span class=nx>setTransform</span><span class=p>(</span><span class=nx>t_x</span><span class=p>,</span> <span class=nx>t_y</span><span class=p>,</span> <span class=nx>t_z</span><span class=p>,</span> <span class=nx>r_x</span><span class=p>,</span> <span class=nx>r_y</span><span class=p>,</span> <span class=nx>r_z</span><span class=p>,</span> <span class=nx>s_x</span><span class=p>,</span> <span class=nx>s_y</span><span class=p>,</span> <span class=nx>s_z</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>	<span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>		<span class=nx>modelTransX</span><span class=o>:</span> <span class=nx>t_x</span><span class=p>,</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>		<span class=nx>modelTransY</span><span class=o>:</span> <span class=nx>t_y</span><span class=p>,</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>		<span class=nx>modelTransZ</span><span class=o>:</span> <span class=nx>t_z</span><span class=p>,</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>		<span class=c1>// Begin TOP changes
</span></span></span><span class=line><span class=ln> 7</span><span class=cl><span class=c1></span>		<span class=nx>modelRotateX</span><span class=o>:</span> <span class=nx>r_x</span><span class=p>,</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>		<span class=nx>modelRotateY</span><span class=o>:</span> <span class=nx>r_y</span><span class=p>,</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>		<span class=nx>modelRotateZ</span><span class=o>:</span> <span class=nx>r_z</span><span class=p>,</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>		<span class=c1>// End TOP changes
</span></span></span><span class=line><span class=ln>11</span><span class=cl><span class=c1></span>		<span class=nx>modelScaleX</span><span class=o>:</span> <span class=nx>s_x</span><span class=p>,</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>		<span class=nx>modelScaleY</span><span class=o>:</span> <span class=nx>s_y</span><span class=p>,</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>		<span class=nx>modelScaleZ</span><span class=o>:</span> <span class=nx>s_z</span><span class=p>,</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>	<span class=p>};</span>
</span></span><span class=line><span class=ln>15</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>然后在上面部分代码设置模型变换中加上旋转的参数，目前先给 0：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504151948322.png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=ln>1</span><span class=cl><span class=kd>let</span> <span class=nx>floorTransform</span> <span class=o>=</span> <span class=nx>setTransform</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>30</span><span class=p>,</span>   <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span>   <span class=mi>4</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=kd>let</span> <span class=nx>obj1Transform</span>  <span class=o>=</span> <span class=nx>setTransform</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span>     <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span>   <span class=mi>20</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>20</span><span class=p>);</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=kd>let</span> <span class=nx>obj2Transform</span>  <span class=o>=</span> <span class=nx>setTransform</span><span class=p>(</span><span class=mi>40</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>40</span><span class=p>,</span>  <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span>   <span class=mi>10</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>10</span><span class=p>);</span>
</span></span></code></pre></div><p>这个变换作为 <code>loadOBJ</code> 函数的参数用于设置模型变换，先看看这个函数干了什么（loadOBJ.js）：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504151955859.png></p><p>涉及到 transform 的地方就这些，一个是 <code>Mesh</code> 的 Ctor，另一个是 material 的 build 函数。</p><p>在 Mesh.js 中，更改其构造函数，增加对旋转的支持：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504152001811.png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=ln> 1</span><span class=cl><span class=c1>// TRSTransform Ctor
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=c1></span>    <span class=nx>constructor</span><span class=p>(</span><span class=nx>translate</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>],</span> <span class=nx>rotate</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>],</span> <span class=nx>scale</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>translate</span> <span class=o>=</span> <span class=nx>translate</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>		<span class=k>this</span><span class=p>.</span><span class=nx>rotate</span> <span class=o>=</span> <span class=nx>rotate</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>scale</span> <span class=o>=</span> <span class=nx>scale</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>    
</span></span><span class=line><span class=ln> 8</span><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=ln> 9</span><span class=cl><span class=c1></span>
</span></span><span class=line><span class=ln>10</span><span class=cl><span class=c1>// Mesh Ctor
</span></span></span><span class=line><span class=ln>11</span><span class=cl><span class=c1></span>		<span class=kr>const</span> <span class=nx>modelTranslation</span> <span class=o>=</span> <span class=p>[</span><span class=nx>transform</span><span class=p>.</span><span class=nx>modelTransX</span><span class=p>,</span> <span class=nx>transform</span><span class=p>.</span><span class=nx>modelTransY</span><span class=p>,</span> <span class=nx>transform</span><span class=p>.</span><span class=nx>modelTransZ</span><span class=p>];</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>		<span class=kr>const</span> <span class=nx>modelRotation</span> <span class=o>=</span> <span class=p>[</span><span class=nx>transform</span><span class=p>.</span><span class=nx>modelRotateX</span><span class=p>,</span> <span class=nx>transform</span><span class=p>.</span><span class=nx>modelRotateY</span><span class=p>,</span> <span class=nx>transform</span><span class=p>.</span><span class=nx>modelRotateZ</span><span class=p>];</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>		<span class=kr>const</span> <span class=nx>modelScale</span> <span class=o>=</span> <span class=p>[</span><span class=nx>transform</span><span class=p>.</span><span class=nx>modelScaleX</span><span class=p>,</span> <span class=nx>transform</span><span class=p>.</span><span class=nx>modelScaleY</span><span class=p>,</span> <span class=nx>transform</span><span class=p>.</span><span class=nx>modelScaleZ</span><span class=p>];</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>		<span class=kd>let</span> <span class=nx>meshTrans</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>TRSTransform</span><span class=p>(</span><span class=nx>modelTranslation</span><span class=p>,</span> <span class=nx>modelRotation</span><span class=p>,</span> <span class=nx>modelScale</span><span class=p>);</span>
</span></span></code></pre></div><p>回到 loadOBJ.js，从传入的 <code>transform</code> 中解析模型旋转，然后传入 material 的 build 函数：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504152005867.png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=ln>1</span><span class=cl><span class=c1>// object.traverse
</span></span></span><span class=line><span class=ln>2</span><span class=cl><span class=c1></span><span class=kd>let</span> <span class=nx>Translation</span> <span class=o>=</span> <span class=p>[</span><span class=nx>transform</span><span class=p>.</span><span class=nx>modelTransX</span><span class=p>,</span> <span class=nx>transform</span><span class=p>.</span><span class=nx>modelTransY</span><span class=p>,</span> <span class=nx>transform</span><span class=p>.</span><span class=nx>modelTransZ</span><span class=p>];</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=kd>let</span> <span class=nx>Rotation</span> <span class=o>=</span> <span class=p>[</span><span class=nx>transform</span><span class=p>.</span><span class=nx>modelRotateX</span><span class=p>,</span> <span class=nx>transform</span><span class=p>.</span><span class=nx>modelRotateY</span><span class=p>,</span> <span class=nx>transform</span><span class=p>.</span><span class=nx>modelRotateZ</span><span class=p>];</span>
</span></span><span class=line><span class=ln>4</span><span class=cl><span class=kd>let</span> <span class=nx>Scale</span> <span class=o>=</span> <span class=p>[</span><span class=nx>transform</span><span class=p>.</span><span class=nx>modelScaleX</span><span class=p>,</span> <span class=nx>transform</span><span class=p>.</span><span class=nx>modelScaleY</span><span class=p>,</span> <span class=nx>transform</span><span class=p>.</span><span class=nx>modelScaleZ</span><span class=p>];</span>
</span></span><span class=line><span class=ln>5</span><span class=cl>
</span></span><span class=line><span class=ln>6</span><span class=cl><span class=nx>material</span> <span class=o>=</span> <span class=nx>buildPhongMaterial</span><span class=p>(</span><span class=nx>colorMap</span><span class=p>,</span> <span class=nx>mat</span><span class=p>.</span><span class=nx>specular</span><span class=p>.</span><span class=nx>toArray</span><span class=p>(),</span> <span class=nx>light</span><span class=p>,</span> <span class=nx>Translation</span><span class=p>,</span> <span class=nx>Rotation</span><span class=p>,</span> <span class=nx>Scale</span><span class=p>,</span> <span class=s2>&#34;./src/shaders/phongShader/phongVertex.glsl&#34;</span><span class=p>,</span> <span class=s2>&#34;./src/shaders/phongShader/phongFragment.glsl&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>7</span><span class=cl><span class=nx>shadowMaterial</span> <span class=o>=</span> <span class=nx>buildShadowMaterial</span><span class=p>(</span><span class=nx>light</span><span class=p>,</span> <span class=nx>Translation</span><span class=p>,</span> <span class=nx>Rotation</span><span class=p>,</span> <span class=nx>Scale</span><span class=p>,</span> <span class=s2>&#34;./src/shaders/shadowShader/shadowVertex.glsl&#34;</span><span class=p>,</span> <span class=s2>&#34;./src/shaders/shadowShader/shadowFragment.glsl&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>然后自然需要对 <code>material</code> 的变换进行支持，依次在 PhongMaterial.js 和 ShadowMaterial.js 中为上述创建材质的函数添加对旋转的支持：</p><p>PhongMaterial.js 中：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504152014479.png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=ln> 1</span><span class=cl><span class=c1>// PhongMaterial Ctor
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=c1></span>    <span class=nx>constructor</span><span class=p>(</span><span class=nx>color</span><span class=p>,</span> <span class=nx>specular</span><span class=p>,</span> <span class=nx>light</span><span class=p>,</span> <span class=nx>translate</span><span class=p>,</span> <span class=nx>rotate</span><span class=p>,</span> <span class=nx>scale</span><span class=p>,</span> <span class=nx>vertexShader</span><span class=p>,</span> <span class=nx>fragmentShader</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>        <span class=kd>let</span> <span class=nx>lightMVP</span> <span class=o>=</span> <span class=nx>light</span><span class=p>.</span><span class=nx>CalcLightMVP</span><span class=p>(</span><span class=nx>translate</span><span class=p>,</span> <span class=nx>rotate</span><span class=p>,</span> <span class=nx>scale</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>
</span></span><span class=line><span class=ln> 5</span><span class=cl><span class=c1>// material builder function
</span></span></span><span class=line><span class=ln> 6</span><span class=cl><span class=c1></span><span class=kr>async</span> <span class=kd>function</span> <span class=nx>buildPhongMaterial</span><span class=p>(</span><span class=nx>color</span><span class=p>,</span> <span class=nx>specular</span><span class=p>,</span> <span class=nx>light</span><span class=p>,</span> <span class=nx>translate</span><span class=p>,</span> <span class=nx>rotate</span><span class=p>,</span> <span class=nx>scale</span><span class=p>,</span> <span class=nx>vertexPath</span><span class=p>,</span> <span class=nx>fragmentPath</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>
</span></span><span class=line><span class=ln> 8</span><span class=cl>    <span class=kd>let</span> <span class=nx>vertexShader</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>getShaderString</span><span class=p>(</span><span class=nx>vertexPath</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>    <span class=kd>let</span> <span class=nx>fragmentShader</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>getShaderString</span><span class=p>(</span><span class=nx>fragmentPath</span><span class=p>);</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>    <span class=k>return</span> <span class=k>new</span> <span class=nx>PhongMaterial</span><span class=p>(</span><span class=nx>color</span><span class=p>,</span> <span class=nx>specular</span><span class=p>,</span> <span class=nx>light</span><span class=p>,</span> <span class=nx>translate</span><span class=p>,</span> <span class=nx>rotate</span><span class=p>,</span> <span class=nx>scale</span><span class=p>,</span> <span class=nx>vertexShader</span><span class=p>,</span> <span class=nx>fragmentShader</span><span class=p>);</span>
</span></span><span class=line><span class=ln>11</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>同样，ShadowMaterial.js 中：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504152017642.png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=ln> 1</span><span class=cl><span class=kr>class</span> <span class=nx>ShadowMaterial</span> <span class=kr>extends</span> <span class=nx>Material</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>    <span class=nx>constructor</span><span class=p>(</span><span class=nx>light</span><span class=p>,</span> <span class=nx>translate</span><span class=p>,</span> <span class=nx>rotate</span><span class=p>,</span> <span class=nx>scale</span><span class=p>,</span> <span class=nx>vertexShader</span><span class=p>,</span> <span class=nx>fragmentShader</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>        <span class=kd>let</span> <span class=nx>lightMVP</span> <span class=o>=</span> <span class=nx>light</span><span class=p>.</span><span class=nx>CalcLightMVP</span><span class=p>(</span><span class=nx>translate</span><span class=p>,</span> <span class=nx>rotate</span><span class=p>,</span> <span class=nx>scale</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>        <span class=kr>super</span><span class=p>({</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>            <span class=s1>&#39;uLightMVP&#39;</span><span class=o>:</span> <span class=p>{</span> <span class=nx>type</span><span class=o>:</span> <span class=s1>&#39;matrix4fv&#39;</span><span class=p>,</span> <span class=nx>value</span><span class=o>:</span> <span class=nx>lightMVP</span> <span class=p>}</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>        <span class=p>},</span> <span class=p>[],</span> <span class=nx>vertexShader</span><span class=p>,</span> <span class=nx>fragmentShader</span><span class=p>,</span> <span class=nx>light</span><span class=p>.</span><span class=nx>fbo</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>
</span></span><span class=line><span class=ln>10</span><span class=cl><span class=kr>async</span> <span class=kd>function</span> <span class=nx>buildShadowMaterial</span><span class=p>(</span><span class=nx>light</span><span class=p>,</span> <span class=nx>translate</span><span class=p>,</span> <span class=nx>rotate</span><span class=p>,</span> <span class=nx>scale</span><span class=p>,</span> <span class=nx>vertexPath</span><span class=p>,</span> <span class=nx>fragmentPath</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>    <span class=kd>let</span> <span class=nx>vertexShader</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>getShaderString</span><span class=p>(</span><span class=nx>vertexPath</span><span class=p>);</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>    <span class=kd>let</span> <span class=nx>fragmentShader</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>getShaderString</span><span class=p>(</span><span class=nx>fragmentPath</span><span class=p>);</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>    <span class=k>return</span> <span class=k>new</span> <span class=nx>ShadowMaterial</span><span class=p>(</span><span class=nx>light</span><span class=p>,</span> <span class=nx>translate</span><span class=p>,</span><span class=nx>rotate</span><span class=p>,</span> <span class=nx>scale</span><span class=p>,</span> <span class=nx>vertexShader</span><span class=p>,</span> <span class=nx>fragmentShader</span><span class=p>);</span>
</span></span><span class=line><span class=ln>14</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>注意到，上面传递的 <code>lightMVP</code> 矩阵是通过 <code>CalcLightMVP</code> 计算的，所以下一步为其增加对旋转的支持，DirectionalLight.js 中：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504152024830.png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=ln> 1</span><span class=cl>    <span class=nx>CalcLightMVP</span><span class=p>(</span><span class=nx>translate</span><span class=p>,</span> <span class=nx>rotate</span><span class=p>,</span> <span class=nx>scale</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>        <span class=kd>let</span> <span class=nx>lightMVP</span> <span class=o>=</span> <span class=nx>mat4</span><span class=p>.</span><span class=nx>create</span><span class=p>();</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>        <span class=kd>let</span> <span class=nx>modelMatrix</span> <span class=o>=</span> <span class=nx>mat4</span><span class=p>.</span><span class=nx>create</span><span class=p>();</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>        <span class=kd>let</span> <span class=nx>viewMatrix</span> <span class=o>=</span> <span class=nx>mat4</span><span class=p>.</span><span class=nx>create</span><span class=p>();</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>        <span class=kd>let</span> <span class=nx>projectionMatrix</span> <span class=o>=</span> <span class=nx>mat4</span><span class=p>.</span><span class=nx>create</span><span class=p>();</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>        
</span></span><span class=line><span class=ln> 7</span><span class=cl>        <span class=c1>// Model transform
</span></span></span><span class=line><span class=ln> 8</span><span class=cl><span class=c1></span>        <span class=nx>mat4</span><span class=p>.</span><span class=nx>translate</span><span class=p>(</span><span class=nx>modelMatrix</span><span class=p>,</span> <span class=nx>modelMatrix</span><span class=p>,</span> <span class=nx>translate</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>        <span class=nx>mat4</span><span class=p>.</span><span class=nx>rotateX</span><span class=p>(</span><span class=nx>modelMatrix</span><span class=p>,</span> <span class=nx>modelMatrix</span><span class=p>,</span> <span class=nx>rotate</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>        <span class=nx>mat4</span><span class=p>.</span><span class=nx>rotateY</span><span class=p>(</span><span class=nx>modelMatrix</span><span class=p>,</span> <span class=nx>modelMatrix</span><span class=p>,</span> <span class=nx>rotate</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>        <span class=nx>mat4</span><span class=p>.</span><span class=nx>rotateZ</span><span class=p>(</span><span class=nx>modelMatrix</span><span class=p>,</span> <span class=nx>modelMatrix</span><span class=p>,</span> <span class=nx>rotate</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>        <span class=nx>mat4</span><span class=p>.</span><span class=nx>scale</span><span class=p>(</span><span class=nx>modelMatrix</span><span class=p>,</span> <span class=nx>modelMatrix</span><span class=p>,</span> <span class=nx>scale</span><span class=p>);</span>
</span></span></code></pre></div><blockquote><p>记得把上面灯的 Mesh（cube）模型变换的旋转参数加上</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=ln>1</span><span class=cl><span class=c1>// DirectionalLight Ctor
</span></span></span><span class=line><span class=ln>2</span><span class=cl><span class=c1></span><span class=k>this</span><span class=p>.</span><span class=nx>mesh</span> <span class=o>=</span> <span class=nx>Mesh</span><span class=p>.</span><span class=nx>cube</span><span class=p>(</span><span class=nx>setTransform</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span>    <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span>    <span class=mf>0.2</span><span class=p>,</span> <span class=mf>0.2</span><span class=p>,</span> <span class=mf>0.2</span><span class=p>,</span>    <span class=mi>0</span><span class=p>));</span>
</span></span></code></pre></div><p>最后，渲染循环每一帧绘制时会调用 <code>WebGLRenderer</code> 的 <code>render</code> 函数，后者又会为每一个实体调用其 <code>meshRender</code> 的 <code>draw</code> 函数，该函数需要调用 <code>bindCameraParameters</code>，这里向 Shader 传递了作为 <code>uniform</code> 的模型变换矩阵，在这里加上旋转（MeshRender.js 中）：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504152038588.png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=ln>1</span><span class=cl><span class=nx>mat4</span><span class=p>.</span><span class=nx>rotateX</span><span class=p>(</span><span class=nx>modelMatrix</span><span class=p>,</span> <span class=nx>modelMatrix</span><span class=p>,</span> <span class=k>this</span><span class=p>.</span><span class=nx>mesh</span><span class=p>.</span><span class=nx>transform</span><span class=p>.</span><span class=nx>rotate</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=nx>mat4</span><span class=p>.</span><span class=nx>rotateY</span><span class=p>(</span><span class=nx>modelMatrix</span><span class=p>,</span> <span class=nx>modelMatrix</span><span class=p>,</span> <span class=k>this</span><span class=p>.</span><span class=nx>mesh</span><span class=p>.</span><span class=nx>transform</span><span class=p>.</span><span class=nx>rotate</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=nx>mat4</span><span class=p>.</span><span class=nx>rotateZ</span><span class=p>(</span><span class=nx>modelMatrix</span><span class=p>,</span> <span class=nx>modelMatrix</span><span class=p>,</span> <span class=k>this</span><span class=p>.</span><span class=nx>mesh</span><span class=p>.</span><span class=nx>transform</span><span class=p>.</span><span class=nx>rotate</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>
</span></span></code></pre></div><p>对旋转的支持到这里就差不多了，现在我们需要让模型随着时间按 Y 轴旋转，我们可以从循环里拿到当前时间，然后与保存的时间相减得到差值，向 <code>render</code> 函数传入这个差值然后每帧累加一个旋转角度即可。</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504152100714.png></p><p>最后，在 WebGLRenderer.js，<code>render</code> 函数中每帧需要更新光源对应的 FBO（帧缓冲区），否则 ShadowMap 的内容会每帧叠加，以及更新传入 Shader 的 <code>uniform</code> 变量。</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504152125258.png></p><p>这里 <code>updateMVP</code> 是我自定义的一个函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=ln>1</span><span class=cl>    <span class=nx>updateMVP</span><span class=p>(</span><span class=nx>mesh</span><span class=p>,</span> <span class=nx>lightEntity</span><span class=p>){</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>        <span class=kd>let</span> <span class=nx>translate</span> <span class=o>=</span> <span class=nx>mesh</span><span class=p>.</span><span class=nx>transform</span><span class=p>.</span><span class=nx>translate</span><span class=p>;</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>        <span class=kd>let</span> <span class=nx>rotate</span> <span class=o>=</span> <span class=nx>mesh</span><span class=p>.</span><span class=nx>transform</span><span class=p>.</span><span class=nx>rotate</span><span class=p>;</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>        <span class=kd>let</span> <span class=nx>scale</span> <span class=o>=</span> <span class=nx>mesh</span><span class=p>.</span><span class=nx>transform</span><span class=p>.</span><span class=nx>scale</span><span class=p>;</span>
</span></span><span class=line><span class=ln>5</span><span class=cl>        <span class=kd>let</span> <span class=nx>MVP</span> <span class=o>=</span> <span class=nx>lightEntity</span><span class=p>.</span><span class=nx>CalcLightMVP</span><span class=p>(</span><span class=nx>translate</span><span class=p>,</span> <span class=nx>rotate</span><span class=p>,</span> <span class=nx>scale</span><span class=p>);</span>
</span></span><span class=line><span class=ln>6</span><span class=cl>        <span class=k>return</span> <span class=nx>MVP</span><span class=p>;</span>
</span></span><span class=line><span class=ln>7</span><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>完成之后就可以转<del>圈</del>圈~</p><p><img alt="转<del>圈</del>圈~" loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/Assignments/Assignment%204.GAMES202HW1/202504152139014.gif></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://congyuxiaoyoudao.github.io/posts/assignments/assignment-3.-games202-homework-0/><span class=title>下一页 »</span><br><span></span></a></nav></footer><div id=tw-comment></div><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="light"?"light":"noborder_dark",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const s={src:"https://giscus.app/client.js","data-repo":"congyuxiaoyoudao/congyuxiaoyoudao.github.io","data-repo-id":"","data-category":"Announcements","data-category-id":"","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"","data-emit-metadata":"","data-input-position":"","data-theme":getStoredTheme(),"data-lang":"zh-CN","data-loading":"lazy",crossorigin:"anonymous"},e=document.createElement("script");Object.entries(s).forEach(([t,n])=>e.setAttribute(t,n)),document.querySelector("#tw-comment").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme);const n=document.querySelector("#theme-toggle-float");n&&n.addEventListener("click",setGiscusTheme)})</script></article></main><footer class=footer><span>&copy; 2025 <a href=https://congyuxiaoyoudao.github.io/>The Only Problem's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>