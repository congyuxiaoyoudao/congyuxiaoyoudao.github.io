<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Interlude 3. WebGPU From Scratch | The Only Problem's Blog</title><meta name=keywords content="WebGPU"><meta name=description content="
从导师那里听说了 WebGPU，做了点调查发现这个 API 还挺新的，正好之前只零零碎碎学了一点 OpenGL，相比于不适合人类学的 Vulkan，还是 WebGPU 显得友好一点。

🚩 0x00 To begin with
这篇文章将会包含以下内容：

 什么是 WebGPU
 配置 WebGPU 开发环境
 第一个 WebGPU 项目：HelloTriangle！

For reference👇：

🍪 







  
  WebGPU Samples


📖 







  
  WebGPU API Spec


📖 







  
  WebGPU Shading Language


📺 







  
  WebGPU小白入门（一）：如何零基础创建第一个WebGPU项目！


📖 







  
  您的第一个 WebGPU 应用


📖 







  
  lil-gui 0.20.0




0x01 认识 WebGPU
WebGPU 是一个由 W3C GPU 工作组制定的新的现代图形 API，用于在 Web 应用中访问 GPU 功能。
在 WebGPU 出现之前，Web 端的图形编程应用主要采用 WebGL 和 WebGL 2，虽然它们有着跨平台能力和强大的社区支持，但架构过于古老，最新的 WebGL 2 只是封装了 2009 年 OpenGL 3.2 的实现。Khronos 也指出 WebGL 后续更新中不再引入现代 GPU 的新特性。"><meta name=author content="The Only Problem"><link rel=canonical href=https://congyuxiaoyoudao.github.io/posts/interludes/webgpu-from-scratch/><link crossorigin=anonymous href=/assets/css/stylesheet.452758010f0b7fc9ad7fa528ffdfdd8eb9e830816fb8c8119f16f39583297db8.css integrity="sha256-RSdYAQ8Lf8mtf6Uo/9/djrnoMIFvuMgRnxbzlYMpfbg=" rel="preload stylesheet" as=style><link rel=icon href=https://congyuxiaoyoudao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://congyuxiaoyoudao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://congyuxiaoyoudao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://congyuxiaoyoudao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://congyuxiaoyoudao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://congyuxiaoyoudao.github.io/posts/interludes/webgpu-from-scratch/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css integrity=sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js integrity=sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js integrity=sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk crossorigin=anonymous onload='window.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\$$",right:"\\\\$$",display:!1},{left:"\\$$",right:"\\\\$$",display:!0}]})})'></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdn.bootcdn.net/ajax/libs/lxgw-wenkai-screen-webfont/1.7.0/style.min.css><meta property="og:url" content="https://congyuxiaoyoudao.github.io/posts/interludes/webgpu-from-scratch/"><meta property="og:site_name" content="The Only Problem's Blog"><meta property="og:title" content="Interlude 3. WebGPU From Scratch"><meta property="og:description" content=" 从导师那里听说了 WebGPU，做了点调查发现这个 API 还挺新的，正好之前只零零碎碎学了一点 OpenGL，相比于不适合人类学的 Vulkan，还是 WebGPU 显得友好一点。
🚩 0x00 To begin with 这篇文章将会包含以下内容：
什么是 WebGPU 配置 WebGPU 开发环境 第一个 WebGPU 项目：HelloTriangle！ For reference👇：
🍪 WebGPU Samples 📖 WebGPU API Spec 📖 WebGPU Shading Language 📺 WebGPU小白入门（一）：如何零基础创建第一个WebGPU项目！ 📖 您的第一个 WebGPU 应用 📖 lil-gui 0.20.0 0x01 认识 WebGPU WebGPU 是一个由 W3C GPU 工作组制定的新的现代图形 API，用于在 Web 应用中访问 GPU 功能。
在 WebGPU 出现之前，Web 端的图形编程应用主要采用 WebGL 和 WebGL 2，虽然它们有着跨平台能力和强大的社区支持，但架构过于古老，最新的 WebGL 2 只是封装了 2009 年 OpenGL 3.2 的实现。Khronos 也指出 WebGL 后续更新中不再引入现代 GPU 的新特性。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-30T00:00:00+00:00"><meta property="article:modified_time" content="2025-06-30T00:00:00+00:00"><meta property="article:tag" content="WebGPU"><meta name=twitter:card content="summary"><meta name=twitter:title content="Interlude 3. WebGPU From Scratch"><meta name=twitter:description content="
从导师那里听说了 WebGPU，做了点调查发现这个 API 还挺新的，正好之前只零零碎碎学了一点 OpenGL，相比于不适合人类学的 Vulkan，还是 WebGPU 显得友好一点。

🚩 0x00 To begin with
这篇文章将会包含以下内容：

 什么是 WebGPU
 配置 WebGPU 开发环境
 第一个 WebGPU 项目：HelloTriangle！

For reference👇：

🍪 







  
  WebGPU Samples


📖 







  
  WebGPU API Spec


📖 







  
  WebGPU Shading Language


📺 







  
  WebGPU小白入门（一）：如何零基础创建第一个WebGPU项目！


📖 







  
  您的第一个 WebGPU 应用


📖 







  
  lil-gui 0.20.0




0x01 认识 WebGPU
WebGPU 是一个由 W3C GPU 工作组制定的新的现代图形 API，用于在 Web 应用中访问 GPU 功能。
在 WebGPU 出现之前，Web 端的图形编程应用主要采用 WebGL 和 WebGL 2，虽然它们有着跨平台能力和强大的社区支持，但架构过于古老，最新的 WebGL 2 只是封装了 2009 年 OpenGL 3.2 的实现。Khronos 也指出 WebGL 后续更新中不再引入现代 GPU 的新特性。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://congyuxiaoyoudao.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Interludes","item":"https://congyuxiaoyoudao.github.io/posts/interludes/"},{"@type":"ListItem","position":3,"name":"Interlude 3. WebGPU From Scratch","item":"https://congyuxiaoyoudao.github.io/posts/interludes/webgpu-from-scratch/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Interlude 3. WebGPU From Scratch","name":"Interlude 3. WebGPU From Scratch","description":" 从导师那里听说了 WebGPU，做了点调查发现这个 API 还挺新的，正好之前只零零碎碎学了一点 OpenGL，相比于不适合人类学的 Vulkan，还是 WebGPU 显得友好一点。\n🚩 0x00 To begin with 这篇文章将会包含以下内容：\n什么是 WebGPU 配置 WebGPU 开发环境 第一个 WebGPU 项目：HelloTriangle！ For reference👇：\n🍪 WebGPU Samples 📖 WebGPU API Spec 📖 WebGPU Shading Language 📺 WebGPU小白入门（一）：如何零基础创建第一个WebGPU项目！ 📖 您的第一个 WebGPU 应用 📖 lil-gui 0.20.0 0x01 认识 WebGPU WebGPU 是一个由 W3C GPU 工作组制定的新的现代图形 API，用于在 Web 应用中访问 GPU 功能。\n在 WebGPU 出现之前，Web 端的图形编程应用主要采用 WebGL 和 WebGL 2，虽然它们有着跨平台能力和强大的社区支持，但架构过于古老，最新的 WebGL 2 只是封装了 2009 年 OpenGL 3.2 的实现。Khronos 也指出 WebGL 后续更新中不再引入现代 GPU 的新特性。\n","keywords":["WebGPU"],"articleBody":" 从导师那里听说了 WebGPU，做了点调查发现这个 API 还挺新的，正好之前只零零碎碎学了一点 OpenGL，相比于不适合人类学的 Vulkan，还是 WebGPU 显得友好一点。\n🚩 0x00 To begin with 这篇文章将会包含以下内容：\n什么是 WebGPU 配置 WebGPU 开发环境 第一个 WebGPU 项目：HelloTriangle！ For reference👇：\n🍪 WebGPU Samples 📖 WebGPU API Spec 📖 WebGPU Shading Language 📺 WebGPU小白入门（一）：如何零基础创建第一个WebGPU项目！ 📖 您的第一个 WebGPU 应用 📖 lil-gui 0.20.0 0x01 认识 WebGPU WebGPU 是一个由 W3C GPU 工作组制定的新的现代图形 API，用于在 Web 应用中访问 GPU 功能。\n在 WebGPU 出现之前，Web 端的图形编程应用主要采用 WebGL 和 WebGL 2，虽然它们有着跨平台能力和强大的社区支持，但架构过于古老，最新的 WebGL 2 只是封装了 2009 年 OpenGL 3.2 的实现。Khronos 也指出 WebGL 后续更新中不再引入现代 GPU 的新特性。\n近 10 年来，GPU 取得了飞速发展，也同时带来了与其交互的现代图形 API 的发展，例如 Metal、D3D 和 Vulkan。WebGPU 继承了这些发展，并将其带到了 Web 平台，可以在浏览器中高效运行 GPU 的通用计算能力。\n作为 WebGL 的继任者，WebGPU 不只是一个能画图 API，还具备强大的并行计算能力，这使得 WebGPU 可以利用 ComputeShader 承担更广泛的计算任务，例如粒子模拟、双调排序等。\n0x02 创建 WebGPU 项目 创建基本 Vite 项目 首先，确保电脑上有如下配置：\nNode.js 支持 WebGPU 的浏览器，如 Chrome 和 Edge（版本 113 以上） 代码编辑器，如 VSCode 进入项目根目录所在文件夹，在终端运行：\n1npm create vite@latest webgpu-render-lab -- --template vanilla-ts 这里的 webgpu-render-lab 是项目名，可任取\n按照指示选择开发模板和变体，这里选择 Vanilla 和 TypeScript，即原生 HTML + TypeScript 的模板。\n然后按照下方提示依次运行：\n1cd webgpu-render-lab 2npm install 3npm run dev 在浏览器访问对应的端口即可看到初始的模板网页。\n目前的项目结构如下：\n1my-webgpu-app/ 2├── node_modules # dependencies 3├── public # static assets 4├── index.html # initial html 5├── src/ 6│ └── main.ts # main TypeScript file 7├── tsconfig.json # TypeScript configure 8├── package.json # Node.js configure 9└── ...others 配置 WebGPU 项目 项目目录下，终端运行：\n1npm install -D @webgpu/types 安装 WebGPU 的 Ts 类型定义文件，然后在 tsconfig.json 的 compilerOptions 中增加一条：\n1// tsconfig.json 2\"compilerOptions\": { 3\t... 4\t\"types\": [\"vite/client\",\"@webgpu/types\"] 5} 以启用 Vite 和 WebGPU 类型的智能提示和类型检查。\ntsconfig.json 中还有一个字段 include，用于告诉 TypeScript 编译器只处理/类型检查所列出路径下的 Ts 文件，以提升速度。\n1// tsconfig.json 2\t\"include\": [\"src\"] 所以如果有 Ts 文件路径不在 src 下，需要在这里包含其所属路径。\n0x03 HelloTriangle 要画世界，先画三角形！\nWebGPU 渲染流程 在正式写程序之前，简单介绍一下 WebGPU 的架构和渲染流程。\n实际上，WebGPU 并非直接操纵硬件，而是运行在浏览器内部的一个抽象层。Web 应用的一个页面处于一个独立的渲染进程中，由 JS 的 API 负责与浏览器进行沟通，后者通过进程间通讯（IPC）将前者传递给 Native Module，再由 Native Module 根据操作系统映射到不同的原生图形 API（Metal、D3D、Vulkan），完成最终的渲染和计算任务。\nNative Module（原生模组）：指由本地系统代码（如 C/C++、Rust）编写、经过编译后供高级语言（如 JavaScript、Python）调用的模块，直接与操作系统或底层硬件交互。Chrome 中的 Dawn 就是一个 Native Module\nWebGPU 的工作流程大致可以分成：初始化、配置管线和录制命令队列三个阶段：\n初始化：获取可供 JS 操作的 GPU 逻辑实例，配置上下文 配置管线：创建管线，创建 Shader 模块，创建 GPU 变量（Buffers、BindGroups） 录制命令队列：开始 Pass，绘制顶点，提交队列 个人感觉，其实也可以把这三个过程合并起来当作一个初始化过程，毕竟在 TS 里写的只是整个渲染逻辑，真正执行绘制行为是由 Native 进程完成的。\n初始化 WebGPU 因为 WebGPU 将渲染结果绘制到 GPUCanvasContext 上，而这个 context 是通过 HTML 的 获取的，所以确保网页的 HTML 文件中至少有一个 canvas 元素，作为 GPU 的渲染目标。\n1\u003ccanvas\u003e\u003c/canvas\u003e 首先检查一下目前的浏览器是否支持 WebGPU，可以用 navigator.gpu 判断，它是 WebGPU 提供给 JS 的入口对象，如果浏览器不支持 WebGPU，则其为 undefined，需要更换合适的浏览器或者开启某个 flag。\n1 if (!navigator.gpu) { 2 throw new Error(\"WebGPU is not supported in this browser.\"); 3 } 4 else{ 5 console.log(\"Hello, WebGPU!\"); 6 } 获得了 WebGPU 支持后，则可以调用 navigator.gpu 的 requestAdapter 获得一个 GPU 的逻辑适配器（adapter），再由 adapter 调用 requestDevice 获得一个实际使用 JS 进行交互的 GPU 设备（device）。\n1const adapter = await navigator.gpu.requestAdapter(); 2const device = await gpuAdapter.requestDevice(); adapter 和 device：GPUAdapter 封装了一个适配器，并描述其特性（features）、限制（limits）及适配器信息（Info），是浏览器对 GPU 的抽象，可以用它选择多个 GPU（集显，独显）；GPUDevice 封装了一个设备，并暴露该设备的功能（只读），代表与 GPU 的逻辑连接，可以用 device 调用 WebGPU 接口。\n正如开头所说，GPUCanvasContext 是通过 HTMLCanvasElement 实例调用 getContext 方法创建的，对于 WebGPU 创建一个 WebGPU 专用的画布上下文，传递 webgpu 作为其 contextType 参数。\n1const canvas = document.querySelector('canvas') as HTMLCanvasElement; 2const context = canvas.getContext('webgpu'); canvas 和 context：类似于 adapter 和 device，canvas 只是一个 HTML 的 DOM 元素，需要通过 getContext 创建一个 WebGPU 可以控制的逻辑画布，在 context 上进行绘制。创建 context 之后，可以通过 configure 方法配置画布上下文，至少包括 device 和 format（GPUTextureFormat），后者一般为 bgra8unorm。\nrequestAdapter 和 requestDevice 都是异步方法，返回一个 Promise，需要使用 await 获取实际返回对象，而 await 必须在 async 函数内部使用，所以可以在外面包裹一个 async function：\n1async function initWebGPU() { 2 // check webgpu support ... 3 // request GPU adapter 4 const adapter = await navigator.gpu.requestAdapter(); 5 if (!adapter) { 6 throw new Error(\"Cannot get GPU adapter.\"); 7 } 8 9 // request a logical device 10 const device = await adapter.requestDevice(); 11 12 // get canvas and configure webgpu context 13 const canvas = document.querySelector('canvas') as HTMLCanvasElement; 14 const context = canvas.getContext('webgpu')!; 15 const presentationFormat = navigator.gpu.getPreferredCanvasFormat(); 16 17 context.configure({ 18 device, 19 format: presentationFormat, 20 alphaMode: 'premultiplied', 21 }); 22 // other code ... 23} 至此，WebGPU 初始化完毕。\n配置管线 WebGPU 一共有两种管线：GPUComputePipeline（计算管线） 和 GPURenderPipeline（渲染管线），无论哪种管线都规定了 GPU 的任务流程，包括从 bindings 或者 buffers 获取输入，并产生输出（例如渲染纹理）的过程。\n从结构上看，管线由一系列可编程阶段（shaders）和固定功能状态（混合模式）组成，一个渲染管线一般包括顶点着色器（vertex shader）、片元着色器（fragment shader）等，计算管线则包括计算着色器（compute shader）。\n对于一个渲染管线，可以通过 createRenderPipeline 方法立即创建并返回一个对象，也可通过 createRenderPipelineAsync 方法异步创建。createRenderPipeline 方法接受一个字典对象 GPURenderPipelineDescriptor，包含如下成员：\nvertex（GPUVertexState）：描述管线顶点着色器入口及其输入缓冲区布局 primitive（GPUPrimitiveState）：描述管线中原始图元相关属性 depthStencil（GPUDepthStencilState）：可选的深度模板属性 multisample（GPUMultisampleState）：多重采样属性 fragment（GPUFragmentState）：描述管线片元着色器入口及其输出颜色 对于此次绘制三角形的任务，我们必须要提供的是 vertex，primitive 和 fragment。其中 vertex 和 fragment 都继承 GPUProgrammableStage，后者描述用户提供的 GPUShaderModule 中的入口点，即着色器的入口函数。\n顶点着色器接受来自顶点缓冲区的输入数据，所以需要先定义需要传输到 GPU 的顶点数据，然后通过 GPUBuffer 描述如何解析这些数据。例如，对于三角形的每个顶点，定义其由位置和颜色两个属性组成：\n1// data preparation 2const triangleData = new Float32Array([ 3// position color 40.0, 0.5, 0.0, 1.0, 0.0, 0.0, 1.0, 5-0.5, -0.5, 0.0, 0.0, 1.0, 0.0, 1.0, 60.5, -0.5, 0.0, 0.0, 0.0, 1.0, 1.0, 7]); 然后可以通过 createBuffer 方法创建一个 GPUbuffer，该方法接受一个 GPUBufferDescriptor 类型的字典对象，至少需要提供两个参数：\nsize：缓冲区以字节为单位的大小 usage：缓冲区允许的使用方式（例如 Vertex，Uniform，Storage） 可以通过上述定义的顶点数组的字节长度获取 size；为了能够拷贝给 GPU，并传递给 VertexBuffer，在 usage 中需要同时启用 VERTEX 和 COPY_DST。\n1// create and write gpu buffer 2const vertexBuffer = device.createBuffer({ 3size: triangleData.byteLength, 4usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST, 5}); 6 7device.queue.writeBuffer(vertexBuffer, 0, triangleData); 定义好了顶点着色器的输入，就可以开始编写 shader 了。正如 OpenGL 有 GLSL，D3D 有 HLSL，WebGPU 的开发组也为其带来了一套新的着色器语言——WGSL。绘制一个三角形所需的最简单的 shader 如下：\n1// shader code 2const shaderCode = ` 3struct VertexOutput { 4 @builtin(position) position: vec4, 5 @location(0) color: vec4, 6}; 7 8@vertex 9fn vs_main( 10 @location(0) pos: vec3, 11 @location(1) color: vec4 12) -\u003e VertexOutput { 13 var output: VertexOutput; 14 output.position = vec4(pos, 1.0); 15 output.color = color; 16 return output; 17} 18 19@fragment 20fn fs_main(input: VertexOutput) -\u003e @location(0) vec4 { 21 return input.color; 22} 23`; 24 25// create shader module 26const shaderModule = device.createShaderModule({ 27code: shaderCode, 28}); shader 也可以写在 .wgsl 文件中，通过 import 导入\n至此，可以调用 createRenderPipeline 方法，依次填入 GPURenderPipelineDescriptor 的各个字段：\nlayout：使用 ‘auto’，让管线自动推断资源绑定布局 vertex：shaderModule 及顶点着色器入口函数，顶点缓冲区布局和格式 fragment：shaderModule 及片元着色器入口函数，输出格式（必须与 context 的 format 匹配） primitive：其中的 topology 规定图元类型，由于我们是画三角形所以使用 ’triangle-list’ 1 // create render pipeline 2 const pipeline = device.createRenderPipeline({ 3 layout: 'auto', 4 vertex: { 5 module: shaderModule, 6 entryPoint: 'vs_main', 7 buffers: [ 8 { 9 arrayStride: 7 * 4, // position: 3 + color: 4 10 attributes: [ 11 { // position 12 shaderLocation: 0, 13 offset: 0, 14 format: 'float32x3', 15 }, 16 { // color 17 shaderLocation: 1, 18 offset: 3 * 4, 19 format: 'float32x4', 20 }, 21 ], 22 }, 23 ], 24 }, 25 fragment: { 26 module: shaderModule, 27 entryPoint: 'fs_main', 28 targets: [ 29 { 30 format: presentationFormat, 31 }, 32 ], 33 }, 34 primitive: { 35 topology: 'triangle-list', 36 }, 37 }); 至此，管线配置结束。\n录制渲染队列 熟悉 Unity 的同学可能会知道，当调用渲染命令时，GPU 并非立即执行，而是把一系列命令写入一个命令缓冲区（CommandBuffer），然后再将这个 CommandBuffer 注入到管线的特定阶段（例如不透明物体渲染后或者阴影渲染前）。当渲染循环执行到注入点时，才会依次执行缓冲区中的命令。\nWebGPU 中的 CommandEncoder 正是对应了写入渲染缓冲区的录制操作，直到 submit 前的内容都是在构建命令列表：\n1const commandEncoder = device.createCommandEncoder(); 2// record command here 3// ... 4const commandBuffer = commandEncoder.finish(); 5device.queue.submit([commandBuffer]); 如果说 GPUCommandEncoder 是一整个录制器，那么 GPURenderPassEncoder 就是其中的一个子录制器，录制一个 Pass 过程中的命令。简单来说，一个 Pass 就是从 GPU 输入数据到输出渲染目标的过程。一个 CommandEncoder 可以创建多个 Pass。\n在 WebGPU 中创建一个 Pass 可以使用 beginRenderPass 方法，接受一个 GPURenderPassDescripter 字典对象，至少需要包含 colorAttachments 字段。colorAttachments 定义了当前 Pass 输出的所有颜色附件，每个 colorAttachment 是一个字典，必须提供以下三个字段：\nview（GPUTextureView）：描述输出此 colorAttachment 的纹理子资源 loadOp（GPULoadOp）：执行 Pass 前对 view 的加载操作（一般为 clear） storeOp（GPUStoreOp）：执行 Pass 后对 view 的存储操作 创建 GPUPassEncoder 后，就可以录制渲染命令了，具体分为三个阶段：\n设置管线：设置该 Pass 使用的管线、渲染状态 绑定资源：设置顶点缓冲、索引缓冲和 BindingGroup 执行绘制：调用 draw 方法绘制顶点 上述流程完成后，便可以通过 end 方法结束 Pass 的录制。对于本次的三角形，其渲染队列的录制过程如下：\n1function frame() { 2 // cmdEncoder to record commands 3 const commandEncoder = device.createCommandEncoder(); 4 5 // get current texture view 6 const textureView = context.getCurrentTexture().createView(); 7 8 // begin render pass 9 const renderPassDescriptor: GPURenderPassDescriptor = { 10 colorAttachments: [ 11 { 12 view: textureView, 13 clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 }, 14 loadOp: 'clear', 15 storeOp: 'store', 16 }, 17 ], 18 }; 19 20 const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor); 21 22 // set pipeline and vertex buffer 23 passEncoder.setPipeline(pipeline); 24 passEncoder.setVertexBuffer(0, vertexBuffer); 25 26 // draw triangle: 3 vertices 27 passEncoder.draw(3); 28 29 // end render pass 30 passEncoder.end(); 31 32 // finish encode and submit 33 device.queue.submit([commandEncoder.finish()]); 34 35 // request next frame 36 requestAnimationFrame(frame); 37 } 38 39 // start render loop 40 requestAnimationFrame(frame); 在终端运行 npm run dev，不出意外就能看到一个五彩斑斓的三角形：\nCSS 自己写\nGUI 目前我们参数是写死在 TS 中，更方便的方式是加入交互的 GUI，可以在浏览器中实时调整参数并查看结果。\nOpenGL 的时候用的是 imgui，但不知为何下载不了其对 js 的封装，所以这里选择的是另一个轻量级的 lil-gui，在终端下载它的包：\n1npm install lil-gui 然后在 TypeScript 文件中引入：\n1import {GUI} from 'lil-gui' 初始化 GUI 并添加三个 color 参数控制三角形每个顶点的颜色：\n1const gui = new GUI(); 2 3const params = { 4colorA: [1, 0, 0, 1], 5colorB: [0, 1, 0, 1], 6colorC: [0, 0, 1, 1], 7}; 8 9gui.addColor(params, 'colorA'); 10gui.addColor(params, 'colorB'); 11gui.addColor(params, 'colorC'); 创建一个 GPUBuffer，将其设置为 UNIFORM，并绑定到 bindGroup：\n1const colorBuffer = device.createBuffer({ 2 size: 4 * 3 * 4, // 3 colors, each with 4 floats 3 usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, 4}) 5 6const bindGroup = device.createBindGroup({ 7 layout: pipeline.getBindGroupLayout(0), 8 entries: [{ 9 binding: 0, 10 resource: { 11\tbuffer: colorBuffer 12 } 13}], 14}); 然后每帧更新这个 Buffer 并设置绑定组：\n1function updateColors(){ 2 device.queue.writeBuffer(colorBuffer, 0, new Float32Array([...params.colorA, ...params.colorB, ...params.colorC])); 3} 4 5function frame(){ 6\t// ... 7 updateColors(); 8 passEncoder.setBindGroup(0, bindGroup); 9} 最后可以在 VertexShader 中解析这个 uniform：\n1struct ColorUniform { 2 colorA: vec4\u003cf32\u003e, 3 colorB: vec4\u003cf32\u003e, 4 colorC: vec4\u003cf32\u003e, 5}; 6 7@group(0) @binding(0) var\u003cuniform\u003e uColors: ColorUniform; 8 9fn getColorByIndex(index: u32) -\u003e vec4\u003cf32\u003e { 10 if (index == 0u) { 11\treturn uColors.colorA; 12 } else if (index == 1u) { 13\treturn uColors.colorB; 14 } else { 15\treturn uColors.colorC; 16 } 17} 18 19@vertex 20fn vs_main( 21 @builtin(vertex_index) vertexindex: u32, 22 @location(0) pos: vec3\u003cf32\u003e, 23 @location(1) color: vec4\u003cf32\u003e 24) -\u003e VertexOutput { 25 var output: VertexOutput; 26 output.position = vec4\u003cf32\u003e(pos, 1.0); 27 output.color = getColorByIndex(vertexindex); 28 return output; 29} 回到浏览器，调整颜色，就可以看到变化了：\n0x0F After words 好了，你已经学会如何使用 WebGPU 绘制三角形了，可以尝试挑战一下制作一个 3DGS 的实时渲染预览器了！\n好吧不开玩笑了，WebGPU 还有极大部分内容是本文没有涵盖的，如果读者有更进一步的需求，文章开头也列出了一些更详细的文档和教程可供参考。如果有一些 OpenGL 或者 WebGL 基础，学 WebGPU 也会更轻松些吧……\n","wordCount":"1355","inLanguage":"zh","datePublished":"2025-06-30T00:00:00Z","dateModified":"2025-06-30T00:00:00Z","author":{"@type":"Person","name":"The Only Problem"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://congyuxiaoyoudao.github.io/posts/interludes/webgpu-from-scratch/"},"publisher":{"@type":"Organization","name":"The Only Problem's Blog","logo":{"@type":"ImageObject","url":"https://congyuxiaoyoudao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://congyuxiaoyoudao.github.io/ accesskey=h title="The Only Problem's Blog (Alt + H)">The Only Problem's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://congyuxiaoyoudao.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://congyuxiaoyoudao.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://congyuxiaoyoudao.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://congyuxiaoyoudao.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://congyuxiaoyoudao.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://congyuxiaoyoudao.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://congyuxiaoyoudao.github.io/posts/interludes/>Interludes</a></div><h1 class="post-title entry-hint-parent">Interlude 3. WebGPU From Scratch</h1><div class=post-meta><span title='2025-06-30 00:00:00 +0000 UTC'>六月 30, 2025</span>&nbsp;·&nbsp;7 分钟&nbsp;·&nbsp;The Only Problem</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#-0x00-to-begin-with aria-label="🚩 0x00 To begin with">🚩 0x00 To begin with</a></li><li><a href=#0x01-%e8%ae%a4%e8%af%86-webgpu aria-label="0x01 认识 WebGPU">0x01 认识 WebGPU</a></li><li><a href=#0x02-%e5%88%9b%e5%bb%ba-webgpu-%e9%a1%b9%e7%9b%ae aria-label="0x02 创建 WebGPU 项目">0x02 创建 WebGPU 项目</a><ul><li><a href=#%e5%88%9b%e5%bb%ba%e5%9f%ba%e6%9c%ac-vite-%e9%a1%b9%e7%9b%ae aria-label="创建基本 Vite 项目">创建基本 Vite 项目</a></li><li><a href=#%e9%85%8d%e7%bd%ae-webgpu-%e9%a1%b9%e7%9b%ae aria-label="配置 WebGPU 项目">配置 WebGPU 项目</a></li></ul></li><li><a href=#0x03-hellotriangle aria-label="0x03 HelloTriangle">0x03 HelloTriangle</a><ul><li><a href=#webgpu-%e6%b8%b2%e6%9f%93%e6%b5%81%e7%a8%8b aria-label="WebGPU 渲染流程">WebGPU 渲染流程</a></li><li><a href=#%e5%88%9d%e5%a7%8b%e5%8c%96-webgpu aria-label="初始化 WebGPU">初始化 WebGPU</a></li><li><a href=#%e9%85%8d%e7%bd%ae%e7%ae%a1%e7%ba%bf aria-label=配置管线>配置管线</a></li><li><a href=#%e5%bd%95%e5%88%b6%e6%b8%b2%e6%9f%93%e9%98%9f%e5%88%97 aria-label=录制渲染队列>录制渲染队列</a></li><li><a href=#gui aria-label=GUI>GUI</a></li></ul></li><li><a href=#0x0f-after-words aria-label="0x0F After words">0x0F After words</a></li></ul></div></details></div><div class=post-content><blockquote><p>从导师那里听说了 WebGPU，做了点调查发现这个 API 还挺新的，正好之前只零零碎碎学了一点 OpenGL，相比于不适合人类学的 Vulkan，还是 WebGPU 显得友好一点。</p></blockquote><hr><h2 id=-0x00-to-begin-with>🚩 0x00 To begin with<a hidden class=anchor aria-hidden=true href=#-0x00-to-begin-with>#</a></h2><p>这篇文章将会包含以下内容：</p><ul><li><input checked disabled type=checkbox> 什么是 WebGPU</li><li><input checked disabled type=checkbox> 配置 WebGPU 开发环境</li><li><input checked disabled type=checkbox> 第一个 WebGPU 项目：HelloTriangle！</li></ul><p><strong>For reference</strong>👇：</p><ul><li>🍪
<a href=https://webgpu.github.io/webgpu-samples/>WebGPU Samples</a></li><li>📖
<a href=https://gpuweb.github.io/gpuweb/>WebGPU API Spec</a></li><li>📖
<a href=https://www.w3.org/TR/WGSL/>WebGPU Shading Language</a></li><li>📺
<a href=https://www.bilibili.com/video/BV1uu411B7uq/>WebGPU小白入门（一）：如何零基础创建第一个WebGPU项目！</a></li><li>📖
<a href="https://codelabs.developers.google.com/your-first-webgpu-app?hl=zh-cn&amp;authuser=0#0">您的第一个 WebGPU 应用</a></li><li>📖
<a href=https://lil-gui.georgealways.com/>lil-gui 0.20.0</a></li></ul><hr><h2 id=0x01-认识-webgpu>0x01 认识 WebGPU<a hidden class=anchor aria-hidden=true href=#0x01-认识-webgpu>#</a></h2><p>WebGPU 是一个由 W3C GPU 工作组制定的新的现代图形 API，用于在 Web 应用中访问 GPU 功能。</p><p>在 WebGPU 出现之前，Web 端的图形编程应用主要采用 WebGL 和 WebGL 2，虽然它们有着跨平台能力和强大的社区支持，但架构过于古老，最新的 WebGL 2 只是封装了 2009 年 OpenGL 3.2 的实现。Khronos 也指出 WebGL 后续更新中不再引入现代 GPU 的新特性。</p><p><img alt="WebGL 发展历史，Orillusion" loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/TA-interludes/Interlude%203.WebGPUFromScratch/202506301450554.png#center></p><p>近 10 年来，GPU 取得了飞速发展，也同时带来了与其交互的现代图形 API 的发展，例如 Metal、D3D 和 Vulkan。WebGPU 继承了这些发展，并将其带到了 Web 平台，可以在浏览器中高效运行 GPU 的通用计算能力。</p><p>作为 WebGL 的继任者，WebGPU 不只是一个能画图 API，还具备强大的并行计算能力，这使得 WebGPU 可以利用 ComputeShader 承担更广泛的计算任务，例如粒子模拟、双调排序等。</p><hr><h2 id=0x02-创建-webgpu-项目>0x02 创建 WebGPU 项目<a hidden class=anchor aria-hidden=true href=#0x02-创建-webgpu-项目>#</a></h2><h3 id=创建基本-vite-项目>创建基本 Vite 项目<a hidden class=anchor aria-hidden=true href=#创建基本-vite-项目>#</a></h3><p>首先，确保电脑上有如下配置：</p><ul><li>Node.js</li><li>支持 WebGPU 的浏览器，如 Chrome 和 Edge（版本 113 以上）</li><li>代码编辑器，如 VSCode</li></ul><p>进入项目根目录所在文件夹，在终端运行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=ln>1</span><span class=cl>npm create vite@latest webgpu-render-lab -- --template vanilla-ts
</span></span></code></pre></div><blockquote><p>这里的 <code>webgpu-render-lab</code> 是项目名，可任取</p></blockquote><p>按照指示选择开发模板和变体，这里选择 Vanilla 和 TypeScript，即原生 HTML + TypeScript 的模板。</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/TA-interludes/Interlude%203.WebGPUFromScratch/202506301322006.png#center></p><p>然后按照下方提示依次运行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=ln>1</span><span class=cl><span class=nb>cd</span> webgpu-render-lab
</span></span><span class=line><span class=ln>2</span><span class=cl>npm install
</span></span><span class=line><span class=ln>3</span><span class=cl>npm run dev
</span></span></code></pre></div><p>在浏览器访问对应的端口即可看到初始的模板网页。</p><p>目前的项目结构如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=ln>1</span><span class=cl>my-webgpu-app/
</span></span><span class=line><span class=ln>2</span><span class=cl>├── node_modules        <span class=c1># dependencies</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>├── public              <span class=c1># static assets</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>├── index.html          <span class=c1># initial html</span>
</span></span><span class=line><span class=ln>5</span><span class=cl>├── src/
</span></span><span class=line><span class=ln>6</span><span class=cl>│   └── main.ts         <span class=c1># main TypeScript file</span>
</span></span><span class=line><span class=ln>7</span><span class=cl>├── tsconfig.json       <span class=c1># TypeScript configure</span>
</span></span><span class=line><span class=ln>8</span><span class=cl>├── package.json        <span class=c1># Node.js configure</span>
</span></span><span class=line><span class=ln>9</span><span class=cl>└── ...others
</span></span></code></pre></div><h3 id=配置-webgpu-项目>配置 WebGPU 项目<a hidden class=anchor aria-hidden=true href=#配置-webgpu-项目>#</a></h3><p>项目目录下，终端运行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=ln>1</span><span class=cl>npm install -D @webgpu/types
</span></span></code></pre></div><p>安装 WebGPU 的 Ts 类型定义文件，然后在 tsconfig.json 的 <code>compilerOptions</code> 中增加一条：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=ln>1</span><span class=cl><span class=c1>// tsconfig.json
</span></span></span><span class=line><span class=ln>2</span><span class=cl><span class=c1></span><span class=s2>&#34;compilerOptions&#34;</span><span class=err>:</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>	 <span class=err>...</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>	<span class=nt>&#34;types&#34;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&#34;vite/client&#34;</span><span class=p>,</span><span class=s2>&#34;@webgpu/types&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=ln>5</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>以启用 Vite 和 WebGPU 类型的智能提示和类型检查。</p><p>tsconfig.json 中还有一个字段 <code>include</code>，用于告诉 TypeScript 编译器只处理/类型检查所列出路径下的 Ts 文件，以提升速度。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=ln>1</span><span class=cl><span class=c1>// tsconfig.json
</span></span></span><span class=line><span class=ln>2</span><span class=cl><span class=c1></span>	<span class=s2>&#34;include&#34;</span><span class=err>:</span> <span class=p>[</span><span class=s2>&#34;src&#34;</span><span class=p>]</span>
</span></span></code></pre></div><p>所以如果有 Ts 文件路径不在 src 下，需要在这里包含其所属路径。</p><hr><h2 id=0x03-hellotriangle>0x03 HelloTriangle<a hidden class=anchor aria-hidden=true href=#0x03-hellotriangle>#</a></h2><blockquote><p>要画世界，先画三角形！</p></blockquote><h3 id=webgpu-渲染流程>WebGPU 渲染流程<a hidden class=anchor aria-hidden=true href=#webgpu-渲染流程>#</a></h3><p>在正式写程序之前，简单介绍一下 WebGPU 的架构和渲染流程。</p><p><img alt="WebGPU 的架构（Chrome），Orillusion" loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/TA-interludes/Interlude%203.WebGPUFromScratch/202506301737646.png#center></p><p>实际上，WebGPU 并非直接操纵硬件，而是运行在浏览器内部的一个抽象层。Web 应用的一个页面处于一个独立的渲染进程中，由 JS 的 API 负责与浏览器进行沟通，后者通过进程间通讯（IPC）将前者传递给 Native Module，再由 Native Module 根据操作系统映射到不同的原生图形 API（Metal、D3D、Vulkan），完成最终的渲染和计算任务。</p><blockquote><p>Native Module（原生模组）：指由本地系统代码（如 C/C++、Rust）编写、经过编译后供高级语言（如 JavaScript、Python）调用的模块，直接与操作系统或底层硬件交互。Chrome 中的 Dawn 就是一个 Native Module</p></blockquote><p>WebGPU 的工作流程大致可以分成：初始化、配置管线和录制命令队列三个阶段：</p><ul><li>初始化：获取可供 JS 操作的 GPU 逻辑实例，配置上下文</li><li>配置管线：创建管线，创建 Shader 模块，创建 GPU 变量（Buffers、BindGroups）</li><li>录制命令队列：开始 Pass，绘制顶点，提交队列</li></ul><p><img alt="WebGPU 工作流，Orillusion" loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/TA-interludes/Interlude%203.WebGPUFromScratch/202506301717915.png#center></p><p>个人感觉，其实也可以把这三个过程合并起来当作一个初始化过程，毕竟在 TS 里写的只是整个渲染逻辑，真正执行绘制行为是由 Native 进程完成的。</p><h3 id=初始化-webgpu>初始化 WebGPU<a hidden class=anchor aria-hidden=true href=#初始化-webgpu>#</a></h3><p>因为 WebGPU 将渲染结果绘制到 <code>GPUCanvasContext</code> 上，而这个 context 是通过 HTML 的 <code>&lt;canvas></code> 获取的，所以确保网页的 HTML 文件中至少有一个 canvas 元素，作为 GPU 的渲染目标。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=ln>1</span><span class=cl><span class=p>&lt;</span><span class=nt>canvas</span><span class=p>&gt;&lt;/</span><span class=nt>canvas</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>首先检查一下目前的浏览器是否支持 WebGPU，可以用 <code>navigator.gpu</code> 判断，它是 WebGPU 提供给 JS 的入口对象，如果浏览器不支持 WebGPU，则其为 undefined，需要更换合适的浏览器或者开启某个 flag。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=ln>1</span><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>navigator</span><span class=p>.</span><span class=nx>gpu</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s2>&#34;WebGPU is not supported in this browser.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>  <span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=ln>5</span><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Hello, WebGPU!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>6</span><span class=cl>  <span class=p>}</span>
</span></span></code></pre></div><p>获得了 WebGPU 支持后，则可以调用 <code>navigator.gpu</code> 的 <code>requestAdapter</code> 获得一个 GPU 的逻辑适配器（adapter），再由 <code>adapter</code> 调用 <code>requestDevice</code> 获得一个实际使用 JS 进行交互的 GPU 设备（device）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=ln>1</span><span class=cl><span class=kr>const</span> <span class=nx>adapter</span> <span class=o>=</span> <span class=k>await</span> <span class=nx>navigator</span><span class=p>.</span><span class=nx>gpu</span><span class=p>.</span><span class=nx>requestAdapter</span><span class=p>();</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=kr>const</span> <span class=nx>device</span> <span class=o>=</span> <span class=k>await</span> <span class=nx>gpuAdapter</span><span class=p>.</span><span class=nx>requestDevice</span><span class=p>();</span>
</span></span></code></pre></div><blockquote><p>adapter 和 device：GPUAdapter 封装了一个适配器，并描述其特性（features）、限制（limits）及适配器信息（Info），是浏览器对 GPU 的抽象，可以用它选择多个 GPU（集显，独显）；GPUDevice 封装了一个设备，并暴露该设备的功能（只读），代表与 GPU 的逻辑连接，可以用 device 调用 WebGPU 接口。</p></blockquote><p>正如开头所说，<code>GPUCanvasContext</code> 是通过 <code>HTMLCanvasElement</code> 实例调用 <code>getContext</code> 方法创建的，对于 WebGPU 创建一个 WebGPU 专用的画布上下文，传递 <code>webgpu</code> 作为其 contextType 参数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=ln>1</span><span class=cl><span class=kr>const</span> <span class=nx>canvas</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>querySelector</span><span class=p>(</span><span class=s1>&#39;canvas&#39;</span><span class=p>)</span> <span class=kr>as</span> <span class=nx>HTMLCanvasElement</span><span class=p>;</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=kr>const</span> <span class=nx>context</span> <span class=o>=</span> <span class=nx>canvas</span><span class=p>.</span><span class=nx>getContext</span><span class=p>(</span><span class=s1>&#39;webgpu&#39;</span><span class=p>);</span>
</span></span></code></pre></div><blockquote><p>canvas 和 context：类似于 adapter 和 device，canvas 只是一个 HTML 的 DOM 元素，需要通过 <code>getContext</code> 创建一个 WebGPU 可以控制的逻辑画布，在 context 上进行绘制。创建 context 之后，可以通过 <code>configure</code> 方法配置画布上下文，至少包括 device 和 format（<code>GPUTextureFormat</code>），后者一般为 bgra8unorm。</p></blockquote><p><code>requestAdapter</code> 和 <code>requestDevice</code> 都是异步方法，返回一个 Promise，需要使用 await 获取实际返回对象，而 await 必须在 async 函数内部使用，所以可以在外面包裹一个 async function：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=ln> 1</span><span class=cl><span class=kr>async</span> <span class=kd>function</span> <span class=nx>initWebGPU() {</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>  <span class=c1>// check webgpu support ...
</span></span></span><span class=line><span class=ln> 3</span><span class=cl><span class=c1></span>  <span class=c1>// request GPU adapter
</span></span></span><span class=line><span class=ln> 4</span><span class=cl><span class=c1></span>  <span class=kr>const</span> <span class=nx>adapter</span> <span class=o>=</span> <span class=k>await</span> <span class=nx>navigator</span><span class=p>.</span><span class=nx>gpu</span><span class=p>.</span><span class=nx>requestAdapter</span><span class=p>();</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>adapter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s2>&#34;Cannot get GPU adapter.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>
</span></span><span class=line><span class=ln> 9</span><span class=cl>  <span class=c1>// request a logical device
</span></span></span><span class=line><span class=ln>10</span><span class=cl><span class=c1></span>  <span class=kr>const</span> <span class=nx>device</span> <span class=o>=</span> <span class=k>await</span> <span class=nx>adapter</span><span class=p>.</span><span class=nx>requestDevice</span><span class=p>();</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>  
</span></span><span class=line><span class=ln>12</span><span class=cl>  <span class=c1>// get canvas and configure webgpu context
</span></span></span><span class=line><span class=ln>13</span><span class=cl><span class=c1></span>  <span class=kr>const</span> <span class=nx>canvas</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>querySelector</span><span class=p>(</span><span class=s1>&#39;canvas&#39;</span><span class=p>)</span> <span class=kr>as</span> <span class=nx>HTMLCanvasElement</span><span class=p>;</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>  <span class=kr>const</span> <span class=nx>context</span> <span class=o>=</span> <span class=nx>canvas</span><span class=p>.</span><span class=nx>getContext</span><span class=p>(</span><span class=s1>&#39;webgpu&#39;</span><span class=p>)</span><span class=o>!</span><span class=p>;</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>  <span class=kr>const</span> <span class=nx>presentationFormat</span> <span class=o>=</span> <span class=nx>navigator</span><span class=p>.</span><span class=nx>gpu</span><span class=p>.</span><span class=nx>getPreferredCanvasFormat</span><span class=p>();</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>  
</span></span><span class=line><span class=ln>17</span><span class=cl>  <span class=nx>context</span><span class=p>.</span><span class=nx>configure</span><span class=p>({</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>    <span class=nx>device</span><span class=p>,</span>
</span></span><span class=line><span class=ln>19</span><span class=cl>    <span class=nx>format</span>: <span class=kt>presentationFormat</span><span class=p>,</span>
</span></span><span class=line><span class=ln>20</span><span class=cl>    <span class=nx>alphaMode</span><span class=o>:</span> <span class=s1>&#39;premultiplied&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=ln>21</span><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=ln>22</span><span class=cl>  <span class=c1>// other code ...
</span></span></span><span class=line><span class=ln>23</span><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>至此，WebGPU 初始化完毕。</p><h3 id=配置管线>配置管线<a hidden class=anchor aria-hidden=true href=#配置管线>#</a></h3><p>WebGPU 一共有两种管线：GPUComputePipeline（计算管线） 和 GPURenderPipeline（渲染管线），无论哪种管线都规定了 GPU 的任务流程，包括从 bindings 或者 buffers 获取输入，并产生输出（例如渲染纹理）的过程。</p><p>从结构上看，管线由一系列可编程阶段（shaders）和固定功能状态（混合模式）组成，一个渲染管线一般包括顶点着色器（vertex shader）、片元着色器（fragment shader）等，计算管线则包括计算着色器（compute shader）。</p><p>对于一个渲染管线，可以通过 <code>createRenderPipeline</code> 方法立即创建并返回一个对象，也可通过 <code>createRenderPipelineAsync</code> 方法异步创建。<code>createRenderPipeline</code> 方法接受一个字典对象 <code>GPURenderPipelineDescriptor</code>，包含如下成员：</p><ul><li>vertex（GPUVertexState）：描述管线顶点着色器入口及其输入缓冲区布局</li><li>primitive（GPUPrimitiveState）：描述管线中原始图元相关属性</li><li>depthStencil（GPUDepthStencilState）：可选的深度模板属性</li><li>multisample（GPUMultisampleState）：多重采样属性</li><li>fragment（GPUFragmentState）：描述管线片元着色器入口及其输出颜色</li></ul><p>对于此次绘制三角形的任务，我们必须要提供的是 vertex，primitive 和 fragment。其中 vertex 和 fragment 都继承 <code>GPUProgrammableStage</code>，后者描述用户提供的 <code>GPUShaderModule</code> 中的入口点，即着色器的入口函数。</p><p>顶点着色器接受来自顶点缓冲区的输入数据，所以需要先定义需要传输到 GPU 的顶点数据，然后通过 GPUBuffer 描述如何解析这些数据。例如，对于三角形的每个顶点，定义其由位置和颜色两个属性组成：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=ln>1</span><span class=cl><span class=c1>// data preparation
</span></span></span><span class=line><span class=ln>2</span><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>triangleData</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Float32Array</span><span class=p>([</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=c1>// position      color
</span></span></span><span class=line><span class=ln>4</span><span class=cl><span class=c1></span><span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span>   <span class=mf>1.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>,</span>
</span></span><span class=line><span class=ln>5</span><span class=cl><span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span>  <span class=mf>0.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>,</span>
</span></span><span class=line><span class=ln>6</span><span class=cl><span class=mf>0.5</span><span class=p>,</span> <span class=o>-</span><span class=mf>0.5</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span>   <span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>,</span>
</span></span><span class=line><span class=ln>7</span><span class=cl><span class=p>]);</span>
</span></span></code></pre></div><p>然后可以通过 <code>createBuffer</code> 方法创建一个 GPUbuffer，该方法接受一个 <code>GPUBufferDescriptor</code> 类型的字典对象，至少需要提供两个参数：</p><ul><li>size：缓冲区以字节为单位的大小</li><li>usage：缓冲区允许的使用方式（例如 Vertex，Uniform，Storage）</li></ul><p>可以通过上述定义的顶点数组的字节长度获取 size；为了能够拷贝给 GPU，并传递给 VertexBuffer，在 usage 中需要同时启用 VERTEX 和 COPY_DST。</p><p><img alt="GPUBufferUsage，WebGPU Spec" loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/TA-interludes/Interlude%203.WebGPUFromScratch/202507011717247.png#center></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=ln>1</span><span class=cl><span class=c1>// create and write gpu buffer
</span></span></span><span class=line><span class=ln>2</span><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>vertexBuffer</span> <span class=o>=</span> <span class=nx>device</span><span class=p>.</span><span class=nx>createBuffer</span><span class=p>({</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=nx>size</span>: <span class=kt>triangleData.byteLength</span><span class=p>,</span>
</span></span><span class=line><span class=ln>4</span><span class=cl><span class=nx>usage</span>: <span class=kt>GPUBufferUsage.VERTEX</span> <span class=o>|</span> <span class=nx>GPUBufferUsage</span><span class=p>.</span><span class=nx>COPY_DST</span><span class=p>,</span>
</span></span><span class=line><span class=ln>5</span><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=ln>6</span><span class=cl>
</span></span><span class=line><span class=ln>7</span><span class=cl><span class=nx>device</span><span class=p>.</span><span class=nx>queue</span><span class=p>.</span><span class=nx>writeBuffer</span><span class=p>(</span><span class=nx>vertexBuffer</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>triangleData</span><span class=p>);</span>
</span></span></code></pre></div><p>定义好了顶点着色器的输入，就可以开始编写 shader 了。正如 OpenGL 有 GLSL，D3D 有 HLSL，WebGPU 的开发组也为其带来了一套新的着色器语言——WGSL。绘制一个三角形所需的最简单的 shader 如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=ln> 1</span><span class=cl><span class=c1>// shader code
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>shaderCode</span> <span class=o>=</span> <span class=sb>`
</span></span></span><span class=line><span class=ln> 3</span><span class=cl><span class=sb>struct VertexOutput {
</span></span></span><span class=line><span class=ln> 4</span><span class=cl><span class=sb>  @builtin(position) position: vec4&lt;f32&gt;,
</span></span></span><span class=line><span class=ln> 5</span><span class=cl><span class=sb>  @location(0) color: vec4&lt;f32&gt;,
</span></span></span><span class=line><span class=ln> 6</span><span class=cl><span class=sb>};
</span></span></span><span class=line><span class=ln> 7</span><span class=cl><span class=sb>
</span></span></span><span class=line><span class=ln> 8</span><span class=cl><span class=sb>@vertex
</span></span></span><span class=line><span class=ln> 9</span><span class=cl><span class=sb>fn vs_main(
</span></span></span><span class=line><span class=ln>10</span><span class=cl><span class=sb>  @location(0) pos: vec3&lt;f32&gt;,
</span></span></span><span class=line><span class=ln>11</span><span class=cl><span class=sb>  @location(1) color: vec4&lt;f32&gt;
</span></span></span><span class=line><span class=ln>12</span><span class=cl><span class=sb>) -&gt; VertexOutput {
</span></span></span><span class=line><span class=ln>13</span><span class=cl><span class=sb>  var output: VertexOutput;
</span></span></span><span class=line><span class=ln>14</span><span class=cl><span class=sb>  output.position = vec4&lt;f32&gt;(pos, 1.0);
</span></span></span><span class=line><span class=ln>15</span><span class=cl><span class=sb>  output.color = color;
</span></span></span><span class=line><span class=ln>16</span><span class=cl><span class=sb>  return output;
</span></span></span><span class=line><span class=ln>17</span><span class=cl><span class=sb>}
</span></span></span><span class=line><span class=ln>18</span><span class=cl><span class=sb>
</span></span></span><span class=line><span class=ln>19</span><span class=cl><span class=sb>@fragment
</span></span></span><span class=line><span class=ln>20</span><span class=cl><span class=sb>fn fs_main(input: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {
</span></span></span><span class=line><span class=ln>21</span><span class=cl><span class=sb>  return input.color;
</span></span></span><span class=line><span class=ln>22</span><span class=cl><span class=sb>}
</span></span></span><span class=line><span class=ln>23</span><span class=cl><span class=sb>`</span><span class=p>;</span>
</span></span><span class=line><span class=ln>24</span><span class=cl>
</span></span><span class=line><span class=ln>25</span><span class=cl><span class=c1>// create shader module
</span></span></span><span class=line><span class=ln>26</span><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>shaderModule</span> <span class=o>=</span> <span class=nx>device</span><span class=p>.</span><span class=nx>createShaderModule</span><span class=p>({</span>
</span></span><span class=line><span class=ln>27</span><span class=cl><span class=nx>code</span>: <span class=kt>shaderCode</span><span class=p>,</span>
</span></span><span class=line><span class=ln>28</span><span class=cl><span class=p>});</span>
</span></span></code></pre></div><blockquote><p>shader 也可以写在 .wgsl 文件中，通过 import 导入</p></blockquote><p>至此，可以调用 <code>createRenderPipeline</code> 方法，依次填入 <code>GPURenderPipelineDescriptor</code> 的各个字段：</p><ul><li>layout：使用 &lsquo;auto&rsquo;，让管线自动推断资源绑定布局</li><li>vertex：shaderModule 及顶点着色器入口函数，顶点缓冲区布局和格式</li><li>fragment：shaderModule 及片元着色器入口函数，输出格式（必须与 context 的 format 匹配）</li><li>primitive：其中的 topology 规定图元类型，由于我们是画三角形所以使用 &rsquo;triangle-list&rsquo;</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=ln> 1</span><span class=cl>  <span class=c1>// create render pipeline
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=c1></span>  <span class=kr>const</span> <span class=nx>pipeline</span> <span class=o>=</span> <span class=nx>device</span><span class=p>.</span><span class=nx>createRenderPipeline</span><span class=p>({</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>    <span class=nx>layout</span><span class=o>:</span> <span class=s1>&#39;auto&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>    <span class=nx>vertex</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>      <span class=nx>module</span>: <span class=kt>shaderModule</span><span class=p>,</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>      <span class=nx>entryPoint</span><span class=o>:</span> <span class=s1>&#39;vs_main&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>      <span class=nx>buffers</span><span class=o>:</span> <span class=p>[</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>          <span class=nx>arrayStride</span>: <span class=kt>7</span> <span class=o>*</span> <span class=mi>4</span><span class=p>,</span> <span class=c1>// position: 3 + color: 4
</span></span></span><span class=line><span class=ln>10</span><span class=cl><span class=c1></span>          <span class=nx>attributes</span><span class=o>:</span> <span class=p>[</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>            <span class=p>{</span> <span class=c1>// position
</span></span></span><span class=line><span class=ln>12</span><span class=cl><span class=c1></span>              <span class=nx>shaderLocation</span>: <span class=kt>0</span><span class=p>,</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>              <span class=nx>offset</span>: <span class=kt>0</span><span class=p>,</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>              <span class=nx>format</span><span class=o>:</span> <span class=s1>&#39;float32x3&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>            <span class=p>},</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>            <span class=p>{</span> <span class=c1>// color
</span></span></span><span class=line><span class=ln>17</span><span class=cl><span class=c1></span>              <span class=nx>shaderLocation</span>: <span class=kt>1</span><span class=p>,</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>              <span class=nx>offset</span>: <span class=kt>3</span> <span class=o>*</span> <span class=mi>4</span><span class=p>,</span>
</span></span><span class=line><span class=ln>19</span><span class=cl>              <span class=nx>format</span><span class=o>:</span> <span class=s1>&#39;float32x4&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=ln>20</span><span class=cl>            <span class=p>},</span>
</span></span><span class=line><span class=ln>21</span><span class=cl>          <span class=p>],</span>
</span></span><span class=line><span class=ln>22</span><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=ln>23</span><span class=cl>      <span class=p>],</span>
</span></span><span class=line><span class=ln>24</span><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=ln>25</span><span class=cl>    <span class=nx>fragment</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>26</span><span class=cl>      <span class=nx>module</span>: <span class=kt>shaderModule</span><span class=p>,</span>
</span></span><span class=line><span class=ln>27</span><span class=cl>      <span class=nx>entryPoint</span><span class=o>:</span> <span class=s1>&#39;fs_main&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=ln>28</span><span class=cl>      <span class=nx>targets</span><span class=o>:</span> <span class=p>[</span>
</span></span><span class=line><span class=ln>29</span><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=ln>30</span><span class=cl>          <span class=nx>format</span>: <span class=kt>presentationFormat</span><span class=p>,</span>
</span></span><span class=line><span class=ln>31</span><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=ln>32</span><span class=cl>      <span class=p>],</span>
</span></span><span class=line><span class=ln>33</span><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=ln>34</span><span class=cl>    <span class=nx>primitive</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>35</span><span class=cl>      <span class=nx>topology</span><span class=o>:</span> <span class=s1>&#39;triangle-list&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=ln>36</span><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=ln>37</span><span class=cl>  <span class=p>});</span>
</span></span></code></pre></div><p>至此，管线配置结束。</p><h3 id=录制渲染队列>录制渲染队列<a hidden class=anchor aria-hidden=true href=#录制渲染队列>#</a></h3><p>熟悉 Unity 的同学可能会知道，当调用渲染命令时，GPU 并非立即执行，而是把一系列命令写入一个命令缓冲区（CommandBuffer），然后再将这个 CommandBuffer 注入到管线的特定阶段（例如不透明物体渲染后或者阴影渲染前）。当渲染循环执行到注入点时，才会依次执行缓冲区中的命令。</p><p>WebGPU 中的 CommandEncoder 正是对应了写入渲染缓冲区的录制操作，直到 submit 前的内容都是在构建命令列表：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=ln>1</span><span class=cl><span class=kr>const</span> <span class=nx>commandEncoder</span> <span class=o>=</span> <span class=nx>device</span><span class=p>.</span><span class=nx>createCommandEncoder</span><span class=p>();</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=c1>// record command here
</span></span></span><span class=line><span class=ln>3</span><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=ln>4</span><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>commandBuffer</span> <span class=o>=</span> <span class=nx>commandEncoder</span><span class=p>.</span><span class=nx>finish</span><span class=p>();</span>
</span></span><span class=line><span class=ln>5</span><span class=cl><span class=nx>device</span><span class=p>.</span><span class=nx>queue</span><span class=p>.</span><span class=nx>submit</span><span class=p>([</span><span class=nx>commandBuffer</span><span class=p>]);</span>
</span></span></code></pre></div><p>如果说 GPUCommandEncoder 是一整个录制器，那么 GPURenderPassEncoder 就是其中的一个子录制器，录制一个 Pass 过程中的命令。简单来说，一个 Pass 就是从 GPU 输入数据到输出渲染目标的过程。一个 CommandEncoder 可以创建多个 Pass。</p><p>在 WebGPU 中创建一个 Pass 可以使用 <code>beginRenderPass</code> 方法，接受一个 <code>GPURenderPassDescripter</code> 字典对象，至少需要包含 <code>colorAttachments</code> 字段。<code>colorAttachments</code> 定义了当前 Pass 输出的所有颜色附件，每个 <code>colorAttachment</code> 是一个字典，必须提供以下三个字段：</p><ul><li>view（GPUTextureView）：描述输出此 <code>colorAttachment</code> 的纹理子资源</li><li>loadOp（GPULoadOp）：执行 Pass 前对 view 的加载操作（一般为 clear）</li><li>storeOp（GPUStoreOp）：执行 Pass 后对 view 的存储操作</li></ul><p>创建 GPUPassEncoder 后，就可以录制渲染命令了，具体分为三个阶段：</p><ol><li>设置管线：设置该 Pass 使用的管线、渲染状态</li><li>绑定资源：设置顶点缓冲、索引缓冲和 BindingGroup</li><li>执行绘制：调用 <code>draw</code> 方法绘制顶点</li></ol><p>上述流程完成后，便可以通过 <code>end</code> 方法结束 Pass 的录制。对于本次的三角形，其渲染队列的录制过程如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=ln> 1</span><span class=cl><span class=kd>function</span> <span class=nx>frame() {</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>    <span class=c1>// cmdEncoder to record commands
</span></span></span><span class=line><span class=ln> 3</span><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>commandEncoder</span> <span class=o>=</span> <span class=nx>device</span><span class=p>.</span><span class=nx>createCommandEncoder</span><span class=p>();</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>    
</span></span><span class=line><span class=ln> 5</span><span class=cl>    <span class=c1>// get current texture view
</span></span></span><span class=line><span class=ln> 6</span><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>textureView</span> <span class=o>=</span> <span class=nx>context</span><span class=p>.</span><span class=nx>getCurrentTexture</span><span class=p>().</span><span class=nx>createView</span><span class=p>();</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>
</span></span><span class=line><span class=ln> 8</span><span class=cl>    <span class=c1>// begin render pass
</span></span></span><span class=line><span class=ln> 9</span><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>renderPassDescriptor</span>: <span class=kt>GPURenderPassDescriptor</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>      <span class=nx>colorAttachments</span><span class=o>:</span> <span class=p>[</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>          <span class=nx>view</span>: <span class=kt>textureView</span><span class=p>,</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>          <span class=nx>clearValue</span><span class=o>:</span> <span class=p>{</span> <span class=nx>r</span>: <span class=kt>0.0</span><span class=p>,</span> <span class=nx>g</span>: <span class=kt>0.0</span><span class=p>,</span> <span class=nx>b</span>: <span class=kt>0.0</span><span class=p>,</span> <span class=nx>a</span>: <span class=kt>1.0</span> <span class=p>},</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>          <span class=nx>loadOp</span><span class=o>:</span> <span class=s1>&#39;clear&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>          <span class=nx>storeOp</span><span class=o>:</span> <span class=s1>&#39;store&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=ln>17</span><span class=cl>      <span class=p>],</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=ln>19</span><span class=cl>
</span></span><span class=line><span class=ln>20</span><span class=cl>    <span class=kr>const</span> <span class=nx>passEncoder</span> <span class=o>=</span> <span class=nx>commandEncoder</span><span class=p>.</span><span class=nx>beginRenderPass</span><span class=p>(</span><span class=nx>renderPassDescriptor</span><span class=p>);</span>
</span></span><span class=line><span class=ln>21</span><span class=cl>    
</span></span><span class=line><span class=ln>22</span><span class=cl>    <span class=c1>// set pipeline and vertex buffer
</span></span></span><span class=line><span class=ln>23</span><span class=cl><span class=c1></span>    <span class=nx>passEncoder</span><span class=p>.</span><span class=nx>setPipeline</span><span class=p>(</span><span class=nx>pipeline</span><span class=p>);</span>
</span></span><span class=line><span class=ln>24</span><span class=cl>    <span class=nx>passEncoder</span><span class=p>.</span><span class=nx>setVertexBuffer</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nx>vertexBuffer</span><span class=p>);</span>
</span></span><span class=line><span class=ln>25</span><span class=cl>    
</span></span><span class=line><span class=ln>26</span><span class=cl>    <span class=c1>// draw triangle: 3 vertices
</span></span></span><span class=line><span class=ln>27</span><span class=cl><span class=c1></span>    <span class=nx>passEncoder</span><span class=p>.</span><span class=nx>draw</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span> 
</span></span><span class=line><span class=ln>28</span><span class=cl>    
</span></span><span class=line><span class=ln>29</span><span class=cl>    <span class=c1>// end render pass
</span></span></span><span class=line><span class=ln>30</span><span class=cl><span class=c1></span>    <span class=nx>passEncoder</span><span class=p>.</span><span class=nx>end</span><span class=p>();</span>
</span></span><span class=line><span class=ln>31</span><span class=cl>    
</span></span><span class=line><span class=ln>32</span><span class=cl>    <span class=c1>// finish encode and submit 
</span></span></span><span class=line><span class=ln>33</span><span class=cl><span class=c1></span>    <span class=nx>device</span><span class=p>.</span><span class=nx>queue</span><span class=p>.</span><span class=nx>submit</span><span class=p>([</span><span class=nx>commandEncoder</span><span class=p>.</span><span class=nx>finish</span><span class=p>()]);</span>
</span></span><span class=line><span class=ln>34</span><span class=cl>
</span></span><span class=line><span class=ln>35</span><span class=cl>    <span class=c1>// request next frame
</span></span></span><span class=line><span class=ln>36</span><span class=cl><span class=c1></span>    <span class=nx>requestAnimationFrame</span><span class=p>(</span><span class=nx>frame</span><span class=p>);</span>
</span></span><span class=line><span class=ln>37</span><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=ln>38</span><span class=cl>
</span></span><span class=line><span class=ln>39</span><span class=cl>  <span class=c1>// start render loop
</span></span></span><span class=line><span class=ln>40</span><span class=cl><span class=c1></span>  <span class=nx>requestAnimationFrame</span><span class=p>(</span><span class=nx>frame</span><span class=p>);</span>
</span></span></code></pre></div><p>在终端运行 npm run dev，不出意外就能看到一个五彩斑斓的三角形：</p><blockquote><p>CSS 自己写</p></blockquote><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/TA-interludes/Interlude%203.WebGPUFromScratch/202507011833718.png#center></p><h3 id=gui>GUI<a hidden class=anchor aria-hidden=true href=#gui>#</a></h3><p>目前我们参数是写死在 TS 中，更方便的方式是加入交互的 GUI，可以在浏览器中实时调整参数并查看结果。</p><p>OpenGL 的时候用的是 imgui，但不知为何下载不了其对 js 的封装，所以这里选择的是另一个轻量级的 lil-gui，在终端下载它的包：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=ln>1</span><span class=cl>npm install lil-gui
</span></span></code></pre></div><p>然后在 TypeScript 文件中引入：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=ln>1</span><span class=cl><span class=kr>import</span> <span class=p>{</span><span class=nx>GUI</span><span class=p>}</span> <span class=kr>from</span> <span class=s1>&#39;lil-gui&#39;</span>
</span></span></code></pre></div><p>初始化 GUI 并添加三个 color 参数控制三角形每个顶点的颜色：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=ln> 1</span><span class=cl><span class=kr>const</span> <span class=nx>gui</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>GUI</span><span class=p>();</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>
</span></span><span class=line><span class=ln> 3</span><span class=cl><span class=kr>const</span> <span class=nx>params</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl><span class=nx>colorA</span><span class=o>:</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl><span class=nx>colorB</span><span class=o>:</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl><span class=nx>colorC</span><span class=o>:</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>
</span></span><span class=line><span class=ln> 9</span><span class=cl><span class=nx>gui</span><span class=p>.</span><span class=nx>addColor</span><span class=p>(</span><span class=nx>params</span><span class=p>,</span> <span class=s1>&#39;colorA&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>10</span><span class=cl><span class=nx>gui</span><span class=p>.</span><span class=nx>addColor</span><span class=p>(</span><span class=nx>params</span><span class=p>,</span> <span class=s1>&#39;colorB&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>11</span><span class=cl><span class=nx>gui</span><span class=p>.</span><span class=nx>addColor</span><span class=p>(</span><span class=nx>params</span><span class=p>,</span> <span class=s1>&#39;colorC&#39;</span><span class=p>);</span>
</span></span></code></pre></div><p>创建一个 GPUBuffer，将其设置为 UNIFORM，并绑定到 bindGroup：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=ln> 1</span><span class=cl><span class=kr>const</span> <span class=nx>colorBuffer</span> <span class=o>=</span> <span class=nx>device</span><span class=p>.</span><span class=nx>createBuffer</span><span class=p>({</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>  <span class=nx>size</span>: <span class=kt>4</span> <span class=o>*</span> <span class=mi>3</span> <span class=o>*</span> <span class=mi>4</span><span class=p>,</span> <span class=c1>// 3 colors, each with 4 floats
</span></span></span><span class=line><span class=ln> 3</span><span class=cl><span class=c1></span>  <span class=nx>usage</span>: <span class=kt>GPUBufferUsage.UNIFORM</span> <span class=o>|</span> <span class=nx>GPUBufferUsage</span><span class=p>.</span><span class=nx>COPY_DST</span><span class=p>,</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl><span class=p>})</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>
</span></span><span class=line><span class=ln> 6</span><span class=cl><span class=kr>const</span> <span class=nx>bindGroup</span> <span class=o>=</span> <span class=nx>device</span><span class=p>.</span><span class=nx>createBindGroup</span><span class=p>({</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>  <span class=nx>layout</span>: <span class=kt>pipeline.getBindGroupLayout</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>  <span class=nx>entries</span><span class=o>:</span> <span class=p>[{</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>    <span class=nx>binding</span>: <span class=kt>0</span><span class=p>,</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>    <span class=nx>resource</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>	  <span class=nx>buffer</span>: <span class=kt>colorBuffer</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=ln>13</span><span class=cl><span class=p>}],</span>
</span></span><span class=line><span class=ln>14</span><span class=cl><span class=p>});</span>
</span></span></code></pre></div><p>然后每帧更新这个 Buffer 并设置绑定组：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=ln>1</span><span class=cl><span class=kd>function</span> <span class=nx>updateColors</span><span class=p>(){</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>  <span class=nx>device</span><span class=p>.</span><span class=nx>queue</span><span class=p>.</span><span class=nx>writeBuffer</span><span class=p>(</span><span class=nx>colorBuffer</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>new</span> <span class=nx>Float32Array</span><span class=p>([...</span><span class=nx>params</span><span class=p>.</span><span class=nx>colorA</span><span class=p>,</span> <span class=p>...</span><span class=nx>params</span><span class=p>.</span><span class=nx>colorB</span><span class=p>,</span> <span class=p>...</span><span class=nx>params</span><span class=p>.</span><span class=nx>colorC</span><span class=p>]));</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>
</span></span><span class=line><span class=ln>5</span><span class=cl><span class=kd>function</span> <span class=nx>frame</span><span class=p>(){</span>
</span></span><span class=line><span class=ln>6</span><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=ln>7</span><span class=cl><span class=c1></span>  <span class=nx>updateColors</span><span class=p>();</span>
</span></span><span class=line><span class=ln>8</span><span class=cl>  <span class=nx>passEncoder</span><span class=p>.</span><span class=nx>setBindGroup</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nx>bindGroup</span><span class=p>);</span>
</span></span><span class=line><span class=ln>9</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>最后可以在 VertexShader 中解析这个 uniform：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-wgsl data-lang=wgsl><span class=line><span class=ln> 1</span><span class=cl><span class=k>struct</span><span class=w> </span><span class=n>ColorUniform</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=w>  </span><span class=n>colorA</span><span class=p>:</span><span class=w> </span><span class=nb>vec4</span><span class=o>&lt;</span><span class=nb>f32</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=ln> 3</span><span class=cl><span class=w>  </span><span class=n>colorB</span><span class=p>:</span><span class=w> </span><span class=nb>vec4</span><span class=o>&lt;</span><span class=nb>f32</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=ln> 4</span><span class=cl><span class=w>  </span><span class=n>colorC</span><span class=p>:</span><span class=w> </span><span class=nb>vec4</span><span class=o>&lt;</span><span class=nb>f32</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=ln> 5</span><span class=cl><span class=w></span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=ln> 6</span><span class=cl><span class=w>
</span></span></span><span class=line><span class=ln> 7</span><span class=cl><span class=w></span><span class=nd>@group</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=nd>@binding</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=kd>var</span><span class=o>&lt;</span><span class=nb>uniform</span><span class=o>&gt;</span><span class=w> </span><span class=n>uColors</span><span class=p>:</span><span class=w> </span><span class=n>ColorUniform</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=ln> 8</span><span class=cl><span class=w>
</span></span></span><span class=line><span class=ln> 9</span><span class=cl><span class=w></span><span class=k>fn</span><span class=w> </span><span class=n>getColorByIndex</span><span class=p>(</span><span class=n>index</span><span class=p>:</span><span class=w> </span><span class=nb>u32</span><span class=p>)</span><span class=w> </span><span class=p>-&gt;</span><span class=w> </span><span class=nb>vec4</span><span class=o>&lt;</span><span class=nb>f32</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=ln>10</span><span class=cl><span class=w>  </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>index</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0u</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=ln>11</span><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=n>uColors</span><span class=p>.</span><span class=n>colorA</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=ln>12</span><span class=cl><span class=w>  </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>index</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>1u</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=ln>13</span><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=n>uColors</span><span class=p>.</span><span class=n>colorB</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=ln>14</span><span class=cl><span class=w>  </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=ln>15</span><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=n>uColors</span><span class=p>.</span><span class=n>colorC</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=ln>16</span><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=ln>17</span><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=ln>18</span><span class=cl><span class=w>
</span></span></span><span class=line><span class=ln>19</span><span class=cl><span class=w></span><span class=nd>@vertex</span><span class=w>
</span></span></span><span class=line><span class=ln>20</span><span class=cl><span class=w></span><span class=k>fn</span><span class=w> </span><span class=n>vs_main</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=ln>21</span><span class=cl><span class=w>  </span><span class=nd>@builtin</span><span class=p>(</span><span class=nb>vertex_index</span><span class=p>)</span><span class=w> </span><span class=n>vertexindex</span><span class=p>:</span><span class=w> </span><span class=nb>u32</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=ln>22</span><span class=cl><span class=w>  </span><span class=nd>@location</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=n>pos</span><span class=p>:</span><span class=w> </span><span class=nb>vec3</span><span class=o>&lt;</span><span class=nb>f32</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=ln>23</span><span class=cl><span class=w>  </span><span class=nd>@location</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=n>color</span><span class=p>:</span><span class=w> </span><span class=nb>vec4</span><span class=o>&lt;</span><span class=nb>f32</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=ln>24</span><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=p>-&gt;</span><span class=w> </span><span class=n>VertexOutput</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=ln>25</span><span class=cl><span class=w>  </span><span class=kd>var</span><span class=w> </span><span class=n>output</span><span class=p>:</span><span class=w> </span><span class=n>VertexOutput</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=ln>26</span><span class=cl><span class=w>  </span><span class=n>output</span><span class=p>.</span><span class=nb>position</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>vec4</span><span class=o>&lt;</span><span class=nb>f32</span><span class=o>&gt;</span><span class=p>(</span><span class=n>pos</span><span class=p>,</span><span class=w> </span><span class=mf>1.0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=ln>27</span><span class=cl><span class=w>  </span><span class=n>output</span><span class=p>.</span><span class=n>color</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>getColorByIndex</span><span class=p>(</span><span class=n>vertexindex</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=ln>28</span><span class=cl><span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>output</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=ln>29</span><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>回到浏览器，调整颜色，就可以看到变化了：</p><p><img loading=lazy src=https://raw.gitmirror.com/congyuxiaoyoudao/Picgo-ImageBed/main/TA-interludes/Interlude%203.WebGPUFromScratch/202507012240629.png#center></p><hr><h2 id=0x0f-after-words>0x0F After words<a hidden class=anchor aria-hidden=true href=#0x0f-after-words>#</a></h2><p><del>好了，你已经学会如何使用 WebGPU 绘制三角形了，可以尝试挑战一下制作一个 3DGS 的实时渲染预览器了！</del></p><p>好吧不开玩笑了，WebGPU 还有极大部分内容是本文没有涵盖的，如果读者有更进一步的需求，文章开头也列出了一些更详细的文档和教程可供参考。如果有一些 OpenGL 或者 WebGL 基础，学 WebGPU 也会更轻松些吧……</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://congyuxiaoyoudao.github.io/tags/webgpu/>WebGPU</a></li></ul><nav class=paginav><a class=prev href=https://congyuxiaoyoudao.github.io/posts/interludes/estimatenormals/><span class=title>« 上一页</span><br><span>Interlude 4. 在点云数据中估计法线</span>
</a><a class=next href=https://congyuxiaoyoudao.github.io/posts/assignments/games202-homework-5/><span class=title>下一页 »</span><br><span>Assignment 8. GAMES202 Homework 5</span></a></nav></footer><div id=tw-comment></div><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="light"?"light":"noborder_dark",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const s={src:"https://giscus.app/client.js","data-repo":"congyuxiaoyoudao/congyuxiaoyoudao.github.io","data-repo-id":"","data-category":"Announcements","data-category-id":"","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"","data-emit-metadata":"","data-input-position":"","data-theme":getStoredTheme(),"data-lang":"zh-CN","data-loading":"lazy",crossorigin:"anonymous"},e=document.createElement("script");Object.entries(s).forEach(([t,n])=>e.setAttribute(t,n)),document.querySelector("#tw-comment").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme);const n=document.querySelector("#theme-toggle-float");n&&n.addEventListener("click",setGiscusTheme)})</script></article></main><footer class=footer><span>&copy; 2025 <a href=https://congyuxiaoyoudao.github.io/>The Only Problem's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>